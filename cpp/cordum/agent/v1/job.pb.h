// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cordum/agent/v1/job.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cordum_2fagent_2fv1_2fjob_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cordum_2fagent_2fv1_2fjob_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cordum_2fagent_2fv1_2fjob_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cordum_2fagent_2fv1_2fjob_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cordum_2fagent_2fv1_2fjob_2eproto;
namespace cordum {
namespace agent {
namespace v1 {
class Budget;
struct BudgetDefaultTypeInternal;
extern BudgetDefaultTypeInternal _Budget_default_instance_;
class ContextHints;
struct ContextHintsDefaultTypeInternal;
extern ContextHintsDefaultTypeInternal _ContextHints_default_instance_;
class JobCancel;
struct JobCancelDefaultTypeInternal;
extern JobCancelDefaultTypeInternal _JobCancel_default_instance_;
class JobMetadata;
struct JobMetadataDefaultTypeInternal;
extern JobMetadataDefaultTypeInternal _JobMetadata_default_instance_;
class JobMetadata_LabelsEntry_DoNotUse;
struct JobMetadata_LabelsEntry_DoNotUseDefaultTypeInternal;
extern JobMetadata_LabelsEntry_DoNotUseDefaultTypeInternal _JobMetadata_LabelsEntry_DoNotUse_default_instance_;
class JobProgress;
struct JobProgressDefaultTypeInternal;
extern JobProgressDefaultTypeInternal _JobProgress_default_instance_;
class JobRequest;
struct JobRequestDefaultTypeInternal;
extern JobRequestDefaultTypeInternal _JobRequest_default_instance_;
class JobRequest_EnvEntry_DoNotUse;
struct JobRequest_EnvEntry_DoNotUseDefaultTypeInternal;
extern JobRequest_EnvEntry_DoNotUseDefaultTypeInternal _JobRequest_EnvEntry_DoNotUse_default_instance_;
class JobRequest_LabelsEntry_DoNotUse;
struct JobRequest_LabelsEntry_DoNotUseDefaultTypeInternal;
extern JobRequest_LabelsEntry_DoNotUseDefaultTypeInternal _JobRequest_LabelsEntry_DoNotUse_default_instance_;
class JobResult;
struct JobResultDefaultTypeInternal;
extern JobResultDefaultTypeInternal _JobResult_default_instance_;
}  // namespace v1
}  // namespace agent
}  // namespace cordum
PROTOBUF_NAMESPACE_OPEN
template<> ::cordum::agent::v1::Budget* Arena::CreateMaybeMessage<::cordum::agent::v1::Budget>(Arena*);
template<> ::cordum::agent::v1::ContextHints* Arena::CreateMaybeMessage<::cordum::agent::v1::ContextHints>(Arena*);
template<> ::cordum::agent::v1::JobCancel* Arena::CreateMaybeMessage<::cordum::agent::v1::JobCancel>(Arena*);
template<> ::cordum::agent::v1::JobMetadata* Arena::CreateMaybeMessage<::cordum::agent::v1::JobMetadata>(Arena*);
template<> ::cordum::agent::v1::JobMetadata_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::cordum::agent::v1::JobMetadata_LabelsEntry_DoNotUse>(Arena*);
template<> ::cordum::agent::v1::JobProgress* Arena::CreateMaybeMessage<::cordum::agent::v1::JobProgress>(Arena*);
template<> ::cordum::agent::v1::JobRequest* Arena::CreateMaybeMessage<::cordum::agent::v1::JobRequest>(Arena*);
template<> ::cordum::agent::v1::JobRequest_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::cordum::agent::v1::JobRequest_EnvEntry_DoNotUse>(Arena*);
template<> ::cordum::agent::v1::JobRequest_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::cordum::agent::v1::JobRequest_LabelsEntry_DoNotUse>(Arena*);
template<> ::cordum::agent::v1::JobResult* Arena::CreateMaybeMessage<::cordum::agent::v1::JobResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cordum {
namespace agent {
namespace v1 {

enum JobPriority : int {
  JOB_PRIORITY_UNSPECIFIED = 0,
  JOB_PRIORITY_INTERACTIVE = 1,
  JOB_PRIORITY_BATCH = 2,
  JOB_PRIORITY_CRITICAL = 3,
  JobPriority_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JobPriority_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JobPriority_IsValid(int value);
constexpr JobPriority JobPriority_MIN = JOB_PRIORITY_UNSPECIFIED;
constexpr JobPriority JobPriority_MAX = JOB_PRIORITY_CRITICAL;
constexpr int JobPriority_ARRAYSIZE = JobPriority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobPriority_descriptor();
template<typename T>
inline const std::string& JobPriority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobPriority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobPriority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobPriority_descriptor(), enum_t_value);
}
inline bool JobPriority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobPriority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobPriority>(
    JobPriority_descriptor(), name, value);
}
enum JobStatus : int {
  JOB_STATUS_UNSPECIFIED = 0,
  JOB_STATUS_PENDING = 1,
  JOB_STATUS_SCHEDULED = 2,
  JOB_STATUS_DISPATCHED = 3,
  JOB_STATUS_RUNNING = 4,
  JOB_STATUS_SUCCEEDED = 5,
  JOB_STATUS_FAILED = 6,
  JOB_STATUS_CANCELLED = 7,
  JOB_STATUS_DENIED = 8,
  JOB_STATUS_TIMEOUT = 9,
  JobStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JobStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JobStatus_IsValid(int value);
constexpr JobStatus JobStatus_MIN = JOB_STATUS_UNSPECIFIED;
constexpr JobStatus JobStatus_MAX = JOB_STATUS_TIMEOUT;
constexpr int JobStatus_ARRAYSIZE = JobStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobStatus_descriptor();
template<typename T>
inline const std::string& JobStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobStatus_descriptor(), enum_t_value);
}
inline bool JobStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobStatus>(
    JobStatus_descriptor(), name, value);
}
enum ActorType : int {
  ACTOR_TYPE_UNSPECIFIED = 0,
  ACTOR_TYPE_HUMAN = 1,
  ACTOR_TYPE_SERVICE = 2,
  ActorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActorType_IsValid(int value);
constexpr ActorType ActorType_MIN = ACTOR_TYPE_UNSPECIFIED;
constexpr ActorType ActorType_MAX = ACTOR_TYPE_SERVICE;
constexpr int ActorType_ARRAYSIZE = ActorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActorType_descriptor();
template<typename T>
inline const std::string& ActorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActorType_descriptor(), enum_t_value);
}
inline bool ActorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActorType>(
    ActorType_descriptor(), name, value);
}
// ===================================================================

class ContextHints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cordum.agent.v1.ContextHints) */ {
 public:
  inline ContextHints() : ContextHints(nullptr) {}
  ~ContextHints() override;
  explicit PROTOBUF_CONSTEXPR ContextHints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContextHints(const ContextHints& from);
  ContextHints(ContextHints&& from) noexcept
    : ContextHints() {
    *this = ::std::move(from);
  }

  inline ContextHints& operator=(const ContextHints& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextHints& operator=(ContextHints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextHints& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContextHints* internal_default_instance() {
    return reinterpret_cast<const ContextHints*>(
               &_ContextHints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ContextHints& a, ContextHints& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextHints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextHints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextHints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContextHints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContextHints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContextHints& from) {
    ContextHints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextHints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cordum.agent.v1.ContextHints";
  }
  protected:
  explicit ContextHints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 4,
    kMaxInputTokensFieldNumber = 1,
    kAllowSummarizationFieldNumber = 2,
    kAllowRetrievalFieldNumber = 3,
  };
  // repeated string tags = 4;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // int32 max_input_tokens = 1;
  void clear_max_input_tokens();
  int32_t max_input_tokens() const;
  void set_max_input_tokens(int32_t value);
  private:
  int32_t _internal_max_input_tokens() const;
  void _internal_set_max_input_tokens(int32_t value);
  public:

  // bool allow_summarization = 2;
  void clear_allow_summarization();
  bool allow_summarization() const;
  void set_allow_summarization(bool value);
  private:
  bool _internal_allow_summarization() const;
  void _internal_set_allow_summarization(bool value);
  public:

  // bool allow_retrieval = 3;
  void clear_allow_retrieval();
  bool allow_retrieval() const;
  void set_allow_retrieval(bool value);
  private:
  bool _internal_allow_retrieval() const;
  void _internal_set_allow_retrieval(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cordum.agent.v1.ContextHints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    int32_t max_input_tokens_;
    bool allow_summarization_;
    bool allow_retrieval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cordum_2fagent_2fv1_2fjob_2eproto;
};
// -------------------------------------------------------------------

class Budget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cordum.agent.v1.Budget) */ {
 public:
  inline Budget() : Budget(nullptr) {}
  ~Budget() override;
  explicit PROTOBUF_CONSTEXPR Budget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Budget(const Budget& from);
  Budget(Budget&& from) noexcept
    : Budget() {
    *this = ::std::move(from);
  }

  inline Budget& operator=(const Budget& from) {
    CopyFrom(from);
    return *this;
  }
  inline Budget& operator=(Budget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Budget& default_instance() {
    return *internal_default_instance();
  }
  static inline const Budget* internal_default_instance() {
    return reinterpret_cast<const Budget*>(
               &_Budget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Budget& a, Budget& b) {
    a.Swap(&b);
  }
  inline void Swap(Budget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Budget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Budget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Budget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Budget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Budget& from) {
    Budget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Budget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cordum.agent.v1.Budget";
  }
  protected:
  explicit Budget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxInputTokensFieldNumber = 1,
    kMaxOutputTokensFieldNumber = 2,
    kMaxTotalTokensFieldNumber = 3,
    kDeadlineMsFieldNumber = 4,
  };
  // int64 max_input_tokens = 1;
  void clear_max_input_tokens();
  int64_t max_input_tokens() const;
  void set_max_input_tokens(int64_t value);
  private:
  int64_t _internal_max_input_tokens() const;
  void _internal_set_max_input_tokens(int64_t value);
  public:

  // int64 max_output_tokens = 2;
  void clear_max_output_tokens();
  int64_t max_output_tokens() const;
  void set_max_output_tokens(int64_t value);
  private:
  int64_t _internal_max_output_tokens() const;
  void _internal_set_max_output_tokens(int64_t value);
  public:

  // int64 max_total_tokens = 3;
  void clear_max_total_tokens();
  int64_t max_total_tokens() const;
  void set_max_total_tokens(int64_t value);
  private:
  int64_t _internal_max_total_tokens() const;
  void _internal_set_max_total_tokens(int64_t value);
  public:

  // int64 deadline_ms = 4;
  void clear_deadline_ms();
  int64_t deadline_ms() const;
  void set_deadline_ms(int64_t value);
  private:
  int64_t _internal_deadline_ms() const;
  void _internal_set_deadline_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cordum.agent.v1.Budget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t max_input_tokens_;
    int64_t max_output_tokens_;
    int64_t max_total_tokens_;
    int64_t deadline_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cordum_2fagent_2fv1_2fjob_2eproto;
};
// -------------------------------------------------------------------

class JobMetadata_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobMetadata_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobMetadata_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  JobMetadata_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR JobMetadata_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit JobMetadata_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const JobMetadata_LabelsEntry_DoNotUse& other);
  static const JobMetadata_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const JobMetadata_LabelsEntry_DoNotUse*>(&_JobMetadata_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "cordum.agent.v1.JobMetadata.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "cordum.agent.v1.JobMetadata.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_cordum_2fagent_2fv1_2fjob_2eproto;
};

// -------------------------------------------------------------------

class JobMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cordum.agent.v1.JobMetadata) */ {
 public:
  inline JobMetadata() : JobMetadata(nullptr) {}
  ~JobMetadata() override;
  explicit PROTOBUF_CONSTEXPR JobMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobMetadata(const JobMetadata& from);
  JobMetadata(JobMetadata&& from) noexcept
    : JobMetadata() {
    *this = ::std::move(from);
  }

  inline JobMetadata& operator=(const JobMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobMetadata& operator=(JobMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobMetadata* internal_default_instance() {
    return reinterpret_cast<const JobMetadata*>(
               &_JobMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(JobMetadata& a, JobMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(JobMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobMetadata& from) {
    JobMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cordum.agent.v1.JobMetadata";
  }
  protected:
  explicit JobMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRiskTagsFieldNumber = 6,
    kRequiresFieldNumber = 7,
    kLabelsFieldNumber = 9,
    kTenantIdFieldNumber = 1,
    kActorIdFieldNumber = 2,
    kIdempotencyKeyFieldNumber = 4,
    kCapabilityFieldNumber = 5,
    kPackIdFieldNumber = 8,
    kActorTypeFieldNumber = 3,
  };
  // repeated string risk_tags = 6;
  int risk_tags_size() const;
  private:
  int _internal_risk_tags_size() const;
  public:
  void clear_risk_tags();
  const std::string& risk_tags(int index) const;
  std::string* mutable_risk_tags(int index);
  void set_risk_tags(int index, const std::string& value);
  void set_risk_tags(int index, std::string&& value);
  void set_risk_tags(int index, const char* value);
  void set_risk_tags(int index, const char* value, size_t size);
  std::string* add_risk_tags();
  void add_risk_tags(const std::string& value);
  void add_risk_tags(std::string&& value);
  void add_risk_tags(const char* value);
  void add_risk_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& risk_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_risk_tags();
  private:
  const std::string& _internal_risk_tags(int index) const;
  std::string* _internal_add_risk_tags();
  public:

  // repeated string requires = 7;
  int requires_size() const;
  private:
  int _internal_requires_size() const;
  public:
  void clear_requires();
  const std::string& requires(int index) const;
  std::string* mutable_requires(int index);
  void set_requires(int index, const std::string& value);
  void set_requires(int index, std::string&& value);
  void set_requires(int index, const char* value);
  void set_requires(int index, const char* value, size_t size);
  std::string* add_requires();
  void add_requires(const std::string& value);
  void add_requires(std::string&& value);
  void add_requires(const char* value);
  void add_requires(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& requires() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_requires();
  private:
  const std::string& _internal_requires(int index) const;
  std::string* _internal_add_requires();
  public:

  // map<string, string> labels = 9;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string tenant_id = 1;
  void clear_tenant_id();
  const std::string& tenant_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenant_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenant_id();
  PROTOBUF_NODISCARD std::string* release_tenant_id();
  void set_allocated_tenant_id(std::string* tenant_id);
  private:
  const std::string& _internal_tenant_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenant_id(const std::string& value);
  std::string* _internal_mutable_tenant_id();
  public:

  // string actor_id = 2;
  void clear_actor_id();
  const std::string& actor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_id();
  PROTOBUF_NODISCARD std::string* release_actor_id();
  void set_allocated_actor_id(std::string* actor_id);
  private:
  const std::string& _internal_actor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_id(const std::string& value);
  std::string* _internal_mutable_actor_id();
  public:

  // string idempotency_key = 4;
  void clear_idempotency_key();
  const std::string& idempotency_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idempotency_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idempotency_key();
  PROTOBUF_NODISCARD std::string* release_idempotency_key();
  void set_allocated_idempotency_key(std::string* idempotency_key);
  private:
  const std::string& _internal_idempotency_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idempotency_key(const std::string& value);
  std::string* _internal_mutable_idempotency_key();
  public:

  // string capability = 5;
  void clear_capability();
  const std::string& capability() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_capability(ArgT0&& arg0, ArgT... args);
  std::string* mutable_capability();
  PROTOBUF_NODISCARD std::string* release_capability();
  void set_allocated_capability(std::string* capability);
  private:
  const std::string& _internal_capability() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_capability(const std::string& value);
  std::string* _internal_mutable_capability();
  public:

  // string pack_id = 8;
  void clear_pack_id();
  const std::string& pack_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pack_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pack_id();
  PROTOBUF_NODISCARD std::string* release_pack_id();
  void set_allocated_pack_id(std::string* pack_id);
  private:
  const std::string& _internal_pack_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pack_id(const std::string& value);
  std::string* _internal_mutable_pack_id();
  public:

  // .cordum.agent.v1.ActorType actor_type = 3;
  void clear_actor_type();
  ::cordum::agent::v1::ActorType actor_type() const;
  void set_actor_type(::cordum::agent::v1::ActorType value);
  private:
  ::cordum::agent::v1::ActorType _internal_actor_type() const;
  void _internal_set_actor_type(::cordum::agent::v1::ActorType value);
  public:

  // @@protoc_insertion_point(class_scope:cordum.agent.v1.JobMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> risk_tags_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> requires_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        JobMetadata_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenant_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idempotency_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr capability_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pack_id_;
    int actor_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cordum_2fagent_2fv1_2fjob_2eproto;
};
// -------------------------------------------------------------------

class JobRequest_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobRequest_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobRequest_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  JobRequest_EnvEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR JobRequest_EnvEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit JobRequest_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const JobRequest_EnvEntry_DoNotUse& other);
  static const JobRequest_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const JobRequest_EnvEntry_DoNotUse*>(&_JobRequest_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "cordum.agent.v1.JobRequest.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "cordum.agent.v1.JobRequest.EnvEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_cordum_2fagent_2fv1_2fjob_2eproto;
};

// -------------------------------------------------------------------

class JobRequest_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobRequest_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobRequest_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  JobRequest_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR JobRequest_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit JobRequest_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const JobRequest_LabelsEntry_DoNotUse& other);
  static const JobRequest_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const JobRequest_LabelsEntry_DoNotUse*>(&_JobRequest_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "cordum.agent.v1.JobRequest.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "cordum.agent.v1.JobRequest.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_cordum_2fagent_2fv1_2fjob_2eproto;
};

// -------------------------------------------------------------------

class JobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cordum.agent.v1.JobRequest) */ {
 public:
  inline JobRequest() : JobRequest(nullptr) {}
  ~JobRequest() override;
  explicit PROTOBUF_CONSTEXPR JobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobRequest(const JobRequest& from);
  JobRequest(JobRequest&& from) noexcept
    : JobRequest() {
    *this = ::std::move(from);
  }

  inline JobRequest& operator=(const JobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobRequest& operator=(JobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobRequest* internal_default_instance() {
    return reinterpret_cast<const JobRequest*>(
               &_JobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(JobRequest& a, JobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobRequest& from) {
    JobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cordum.agent.v1.JobRequest";
  }
  protected:
  explicit JobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEnvFieldNumber = 6,
    kLabelsFieldNumber = 15,
    kJobIdFieldNumber = 1,
    kTopicFieldNumber = 2,
    kContextPtrFieldNumber = 4,
    kAdapterIdFieldNumber = 5,
    kParentJobIdFieldNumber = 7,
    kWorkflowIdFieldNumber = 8,
    kMemoryIdFieldNumber = 10,
    kTenantIdFieldNumber = 13,
    kPrincipalIdFieldNumber = 14,
    kContextHintsFieldNumber = 11,
    kBudgetFieldNumber = 12,
    kMetaFieldNumber = 16,
    kPriorityFieldNumber = 3,
    kStepIndexFieldNumber = 9,
  };
  // map<string, string> env = 6;
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // map<string, string> labels = 15;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string topic = 2;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // string context_ptr = 4;
  void clear_context_ptr();
  const std::string& context_ptr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_context_ptr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_context_ptr();
  PROTOBUF_NODISCARD std::string* release_context_ptr();
  void set_allocated_context_ptr(std::string* context_ptr);
  private:
  const std::string& _internal_context_ptr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_context_ptr(const std::string& value);
  std::string* _internal_mutable_context_ptr();
  public:

  // string adapter_id = 5;
  void clear_adapter_id();
  const std::string& adapter_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_adapter_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_adapter_id();
  PROTOBUF_NODISCARD std::string* release_adapter_id();
  void set_allocated_adapter_id(std::string* adapter_id);
  private:
  const std::string& _internal_adapter_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adapter_id(const std::string& value);
  std::string* _internal_mutable_adapter_id();
  public:

  // string parent_job_id = 7;
  void clear_parent_job_id();
  const std::string& parent_job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_job_id();
  PROTOBUF_NODISCARD std::string* release_parent_job_id();
  void set_allocated_parent_job_id(std::string* parent_job_id);
  private:
  const std::string& _internal_parent_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_job_id(const std::string& value);
  std::string* _internal_mutable_parent_job_id();
  public:

  // string workflow_id = 8;
  void clear_workflow_id();
  const std::string& workflow_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workflow_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workflow_id();
  PROTOBUF_NODISCARD std::string* release_workflow_id();
  void set_allocated_workflow_id(std::string* workflow_id);
  private:
  const std::string& _internal_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow_id(const std::string& value);
  std::string* _internal_mutable_workflow_id();
  public:

  // string memory_id = 10;
  void clear_memory_id();
  const std::string& memory_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory_id();
  PROTOBUF_NODISCARD std::string* release_memory_id();
  void set_allocated_memory_id(std::string* memory_id);
  private:
  const std::string& _internal_memory_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory_id(const std::string& value);
  std::string* _internal_mutable_memory_id();
  public:

  // string tenant_id = 13;
  void clear_tenant_id();
  const std::string& tenant_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenant_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenant_id();
  PROTOBUF_NODISCARD std::string* release_tenant_id();
  void set_allocated_tenant_id(std::string* tenant_id);
  private:
  const std::string& _internal_tenant_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenant_id(const std::string& value);
  std::string* _internal_mutable_tenant_id();
  public:

  // string principal_id = 14;
  void clear_principal_id();
  const std::string& principal_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_principal_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_principal_id();
  PROTOBUF_NODISCARD std::string* release_principal_id();
  void set_allocated_principal_id(std::string* principal_id);
  private:
  const std::string& _internal_principal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_principal_id(const std::string& value);
  std::string* _internal_mutable_principal_id();
  public:

  // .cordum.agent.v1.ContextHints context_hints = 11;
  bool has_context_hints() const;
  private:
  bool _internal_has_context_hints() const;
  public:
  void clear_context_hints();
  const ::cordum::agent::v1::ContextHints& context_hints() const;
  PROTOBUF_NODISCARD ::cordum::agent::v1::ContextHints* release_context_hints();
  ::cordum::agent::v1::ContextHints* mutable_context_hints();
  void set_allocated_context_hints(::cordum::agent::v1::ContextHints* context_hints);
  private:
  const ::cordum::agent::v1::ContextHints& _internal_context_hints() const;
  ::cordum::agent::v1::ContextHints* _internal_mutable_context_hints();
  public:
  void unsafe_arena_set_allocated_context_hints(
      ::cordum::agent::v1::ContextHints* context_hints);
  ::cordum::agent::v1::ContextHints* unsafe_arena_release_context_hints();

  // .cordum.agent.v1.Budget budget = 12;
  bool has_budget() const;
  private:
  bool _internal_has_budget() const;
  public:
  void clear_budget();
  const ::cordum::agent::v1::Budget& budget() const;
  PROTOBUF_NODISCARD ::cordum::agent::v1::Budget* release_budget();
  ::cordum::agent::v1::Budget* mutable_budget();
  void set_allocated_budget(::cordum::agent::v1::Budget* budget);
  private:
  const ::cordum::agent::v1::Budget& _internal_budget() const;
  ::cordum::agent::v1::Budget* _internal_mutable_budget();
  public:
  void unsafe_arena_set_allocated_budget(
      ::cordum::agent::v1::Budget* budget);
  ::cordum::agent::v1::Budget* unsafe_arena_release_budget();

  // .cordum.agent.v1.JobMetadata meta = 16;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::cordum::agent::v1::JobMetadata& meta() const;
  PROTOBUF_NODISCARD ::cordum::agent::v1::JobMetadata* release_meta();
  ::cordum::agent::v1::JobMetadata* mutable_meta();
  void set_allocated_meta(::cordum::agent::v1::JobMetadata* meta);
  private:
  const ::cordum::agent::v1::JobMetadata& _internal_meta() const;
  ::cordum::agent::v1::JobMetadata* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::cordum::agent::v1::JobMetadata* meta);
  ::cordum::agent::v1::JobMetadata* unsafe_arena_release_meta();

  // .cordum.agent.v1.JobPriority priority = 3;
  void clear_priority();
  ::cordum::agent::v1::JobPriority priority() const;
  void set_priority(::cordum::agent::v1::JobPriority value);
  private:
  ::cordum::agent::v1::JobPriority _internal_priority() const;
  void _internal_set_priority(::cordum::agent::v1::JobPriority value);
  public:

  // int32 step_index = 9;
  void clear_step_index();
  int32_t step_index() const;
  void set_step_index(int32_t value);
  private:
  int32_t _internal_step_index() const;
  void _internal_set_step_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cordum.agent.v1.JobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        JobRequest_EnvEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> env_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        JobRequest_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr context_ptr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adapter_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workflow_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenant_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr principal_id_;
    ::cordum::agent::v1::ContextHints* context_hints_;
    ::cordum::agent::v1::Budget* budget_;
    ::cordum::agent::v1::JobMetadata* meta_;
    int priority_;
    int32_t step_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cordum_2fagent_2fv1_2fjob_2eproto;
};
// -------------------------------------------------------------------

class JobResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cordum.agent.v1.JobResult) */ {
 public:
  inline JobResult() : JobResult(nullptr) {}
  ~JobResult() override;
  explicit PROTOBUF_CONSTEXPR JobResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobResult(const JobResult& from);
  JobResult(JobResult&& from) noexcept
    : JobResult() {
    *this = ::std::move(from);
  }

  inline JobResult& operator=(const JobResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobResult& operator=(JobResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobResult* internal_default_instance() {
    return reinterpret_cast<const JobResult*>(
               &_JobResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(JobResult& a, JobResult& b) {
    a.Swap(&b);
  }
  inline void Swap(JobResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobResult& from) {
    JobResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cordum.agent.v1.JobResult";
  }
  protected:
  explicit JobResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactPtrsFieldNumber = 8,
    kJobIdFieldNumber = 1,
    kResultPtrFieldNumber = 3,
    kWorkerIdFieldNumber = 4,
    kErrorCodeFieldNumber = 6,
    kErrorMessageFieldNumber = 7,
    kExecutionMsFieldNumber = 5,
    kStatusFieldNumber = 2,
  };
  // repeated string artifact_ptrs = 8;
  int artifact_ptrs_size() const;
  private:
  int _internal_artifact_ptrs_size() const;
  public:
  void clear_artifact_ptrs();
  const std::string& artifact_ptrs(int index) const;
  std::string* mutable_artifact_ptrs(int index);
  void set_artifact_ptrs(int index, const std::string& value);
  void set_artifact_ptrs(int index, std::string&& value);
  void set_artifact_ptrs(int index, const char* value);
  void set_artifact_ptrs(int index, const char* value, size_t size);
  std::string* add_artifact_ptrs();
  void add_artifact_ptrs(const std::string& value);
  void add_artifact_ptrs(std::string&& value);
  void add_artifact_ptrs(const char* value);
  void add_artifact_ptrs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& artifact_ptrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_artifact_ptrs();
  private:
  const std::string& _internal_artifact_ptrs(int index) const;
  std::string* _internal_add_artifact_ptrs();
  public:

  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string result_ptr = 3;
  void clear_result_ptr();
  const std::string& result_ptr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_ptr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_ptr();
  PROTOBUF_NODISCARD std::string* release_result_ptr();
  void set_allocated_result_ptr(std::string* result_ptr);
  private:
  const std::string& _internal_result_ptr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_ptr(const std::string& value);
  std::string* _internal_mutable_result_ptr();
  public:

  // string worker_id = 4;
  void clear_worker_id();
  const std::string& worker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_id();
  PROTOBUF_NODISCARD std::string* release_worker_id();
  void set_allocated_worker_id(std::string* worker_id);
  private:
  const std::string& _internal_worker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(const std::string& value);
  std::string* _internal_mutable_worker_id();
  public:

  // string error_code = 6;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // string error_message = 7;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int64 execution_ms = 5;
  void clear_execution_ms();
  int64_t execution_ms() const;
  void set_execution_ms(int64_t value);
  private:
  int64_t _internal_execution_ms() const;
  void _internal_set_execution_ms(int64_t value);
  public:

  // .cordum.agent.v1.JobStatus status = 2;
  void clear_status();
  ::cordum::agent::v1::JobStatus status() const;
  void set_status(::cordum::agent::v1::JobStatus value);
  private:
  ::cordum::agent::v1::JobStatus _internal_status() const;
  void _internal_set_status(::cordum::agent::v1::JobStatus value);
  public:

  // @@protoc_insertion_point(class_scope:cordum.agent.v1.JobResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> artifact_ptrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_ptr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int64_t execution_ms_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cordum_2fagent_2fv1_2fjob_2eproto;
};
// -------------------------------------------------------------------

class JobProgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cordum.agent.v1.JobProgress) */ {
 public:
  inline JobProgress() : JobProgress(nullptr) {}
  ~JobProgress() override;
  explicit PROTOBUF_CONSTEXPR JobProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobProgress(const JobProgress& from);
  JobProgress(JobProgress&& from) noexcept
    : JobProgress() {
    *this = ::std::move(from);
  }

  inline JobProgress& operator=(const JobProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobProgress& operator=(JobProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobProgress* internal_default_instance() {
    return reinterpret_cast<const JobProgress*>(
               &_JobProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(JobProgress& a, JobProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(JobProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobProgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobProgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobProgress& from) {
    JobProgress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cordum.agent.v1.JobProgress";
  }
  protected:
  explicit JobProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactPtrsFieldNumber = 6,
    kJobIdFieldNumber = 1,
    kStepIdFieldNumber = 2,
    kMessageFieldNumber = 4,
    kResultPtrFieldNumber = 5,
    kPercentFieldNumber = 3,
    kStatusFieldNumber = 7,
  };
  // repeated string artifact_ptrs = 6;
  int artifact_ptrs_size() const;
  private:
  int _internal_artifact_ptrs_size() const;
  public:
  void clear_artifact_ptrs();
  const std::string& artifact_ptrs(int index) const;
  std::string* mutable_artifact_ptrs(int index);
  void set_artifact_ptrs(int index, const std::string& value);
  void set_artifact_ptrs(int index, std::string&& value);
  void set_artifact_ptrs(int index, const char* value);
  void set_artifact_ptrs(int index, const char* value, size_t size);
  std::string* add_artifact_ptrs();
  void add_artifact_ptrs(const std::string& value);
  void add_artifact_ptrs(std::string&& value);
  void add_artifact_ptrs(const char* value);
  void add_artifact_ptrs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& artifact_ptrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_artifact_ptrs();
  private:
  const std::string& _internal_artifact_ptrs(int index) const;
  std::string* _internal_add_artifact_ptrs();
  public:

  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string step_id = 2;
  void clear_step_id();
  const std::string& step_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_id();
  PROTOBUF_NODISCARD std::string* release_step_id();
  void set_allocated_step_id(std::string* step_id);
  private:
  const std::string& _internal_step_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_id(const std::string& value);
  std::string* _internal_mutable_step_id();
  public:

  // string message = 4;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string result_ptr = 5;
  void clear_result_ptr();
  const std::string& result_ptr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_ptr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_ptr();
  PROTOBUF_NODISCARD std::string* release_result_ptr();
  void set_allocated_result_ptr(std::string* result_ptr);
  private:
  const std::string& _internal_result_ptr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_ptr(const std::string& value);
  std::string* _internal_mutable_result_ptr();
  public:

  // int32 percent = 3;
  void clear_percent();
  int32_t percent() const;
  void set_percent(int32_t value);
  private:
  int32_t _internal_percent() const;
  void _internal_set_percent(int32_t value);
  public:

  // .cordum.agent.v1.JobStatus status = 7;
  void clear_status();
  ::cordum::agent::v1::JobStatus status() const;
  void set_status(::cordum::agent::v1::JobStatus value);
  private:
  ::cordum::agent::v1::JobStatus _internal_status() const;
  void _internal_set_status(::cordum::agent::v1::JobStatus value);
  public:

  // @@protoc_insertion_point(class_scope:cordum.agent.v1.JobProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> artifact_ptrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_ptr_;
    int32_t percent_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cordum_2fagent_2fv1_2fjob_2eproto;
};
// -------------------------------------------------------------------

class JobCancel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cordum.agent.v1.JobCancel) */ {
 public:
  inline JobCancel() : JobCancel(nullptr) {}
  ~JobCancel() override;
  explicit PROTOBUF_CONSTEXPR JobCancel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobCancel(const JobCancel& from);
  JobCancel(JobCancel&& from) noexcept
    : JobCancel() {
    *this = ::std::move(from);
  }

  inline JobCancel& operator=(const JobCancel& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobCancel& operator=(JobCancel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobCancel& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobCancel* internal_default_instance() {
    return reinterpret_cast<const JobCancel*>(
               &_JobCancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(JobCancel& a, JobCancel& b) {
    a.Swap(&b);
  }
  inline void Swap(JobCancel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobCancel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobCancel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobCancel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobCancel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobCancel& from) {
    JobCancel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobCancel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cordum.agent.v1.JobCancel";
  }
  protected:
  explicit JobCancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kReasonFieldNumber = 2,
    kRequestedByFieldNumber = 3,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // string requested_by = 3;
  void clear_requested_by();
  const std::string& requested_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requested_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requested_by();
  PROTOBUF_NODISCARD std::string* release_requested_by();
  void set_allocated_requested_by(std::string* requested_by);
  private:
  const std::string& _internal_requested_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requested_by(const std::string& value);
  std::string* _internal_mutable_requested_by();
  public:

  // @@protoc_insertion_point(class_scope:cordum.agent.v1.JobCancel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requested_by_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cordum_2fagent_2fv1_2fjob_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ContextHints

// int32 max_input_tokens = 1;
inline void ContextHints::clear_max_input_tokens() {
  _impl_.max_input_tokens_ = 0;
}
inline int32_t ContextHints::_internal_max_input_tokens() const {
  return _impl_.max_input_tokens_;
}
inline int32_t ContextHints::max_input_tokens() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.ContextHints.max_input_tokens)
  return _internal_max_input_tokens();
}
inline void ContextHints::_internal_set_max_input_tokens(int32_t value) {
  
  _impl_.max_input_tokens_ = value;
}
inline void ContextHints::set_max_input_tokens(int32_t value) {
  _internal_set_max_input_tokens(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.ContextHints.max_input_tokens)
}

// bool allow_summarization = 2;
inline void ContextHints::clear_allow_summarization() {
  _impl_.allow_summarization_ = false;
}
inline bool ContextHints::_internal_allow_summarization() const {
  return _impl_.allow_summarization_;
}
inline bool ContextHints::allow_summarization() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.ContextHints.allow_summarization)
  return _internal_allow_summarization();
}
inline void ContextHints::_internal_set_allow_summarization(bool value) {
  
  _impl_.allow_summarization_ = value;
}
inline void ContextHints::set_allow_summarization(bool value) {
  _internal_set_allow_summarization(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.ContextHints.allow_summarization)
}

// bool allow_retrieval = 3;
inline void ContextHints::clear_allow_retrieval() {
  _impl_.allow_retrieval_ = false;
}
inline bool ContextHints::_internal_allow_retrieval() const {
  return _impl_.allow_retrieval_;
}
inline bool ContextHints::allow_retrieval() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.ContextHints.allow_retrieval)
  return _internal_allow_retrieval();
}
inline void ContextHints::_internal_set_allow_retrieval(bool value) {
  
  _impl_.allow_retrieval_ = value;
}
inline void ContextHints::set_allow_retrieval(bool value) {
  _internal_set_allow_retrieval(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.ContextHints.allow_retrieval)
}

// repeated string tags = 4;
inline int ContextHints::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int ContextHints::tags_size() const {
  return _internal_tags_size();
}
inline void ContextHints::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* ContextHints::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:cordum.agent.v1.ContextHints.tags)
  return _s;
}
inline const std::string& ContextHints::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& ContextHints::tags(int index) const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.ContextHints.tags)
  return _internal_tags(index);
}
inline std::string* ContextHints::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.ContextHints.tags)
  return _impl_.tags_.Mutable(index);
}
inline void ContextHints::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.ContextHints.tags)
}
inline void ContextHints::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cordum.agent.v1.ContextHints.tags)
}
inline void ContextHints::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cordum.agent.v1.ContextHints.tags)
}
inline void ContextHints::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cordum.agent.v1.ContextHints.tags)
}
inline std::string* ContextHints::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void ContextHints::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cordum.agent.v1.ContextHints.tags)
}
inline void ContextHints::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cordum.agent.v1.ContextHints.tags)
}
inline void ContextHints::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cordum.agent.v1.ContextHints.tags)
}
inline void ContextHints::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cordum.agent.v1.ContextHints.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContextHints::tags() const {
  // @@protoc_insertion_point(field_list:cordum.agent.v1.ContextHints.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContextHints::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:cordum.agent.v1.ContextHints.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// Budget

// int64 max_input_tokens = 1;
inline void Budget::clear_max_input_tokens() {
  _impl_.max_input_tokens_ = int64_t{0};
}
inline int64_t Budget::_internal_max_input_tokens() const {
  return _impl_.max_input_tokens_;
}
inline int64_t Budget::max_input_tokens() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.Budget.max_input_tokens)
  return _internal_max_input_tokens();
}
inline void Budget::_internal_set_max_input_tokens(int64_t value) {
  
  _impl_.max_input_tokens_ = value;
}
inline void Budget::set_max_input_tokens(int64_t value) {
  _internal_set_max_input_tokens(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.Budget.max_input_tokens)
}

// int64 max_output_tokens = 2;
inline void Budget::clear_max_output_tokens() {
  _impl_.max_output_tokens_ = int64_t{0};
}
inline int64_t Budget::_internal_max_output_tokens() const {
  return _impl_.max_output_tokens_;
}
inline int64_t Budget::max_output_tokens() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.Budget.max_output_tokens)
  return _internal_max_output_tokens();
}
inline void Budget::_internal_set_max_output_tokens(int64_t value) {
  
  _impl_.max_output_tokens_ = value;
}
inline void Budget::set_max_output_tokens(int64_t value) {
  _internal_set_max_output_tokens(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.Budget.max_output_tokens)
}

// int64 max_total_tokens = 3;
inline void Budget::clear_max_total_tokens() {
  _impl_.max_total_tokens_ = int64_t{0};
}
inline int64_t Budget::_internal_max_total_tokens() const {
  return _impl_.max_total_tokens_;
}
inline int64_t Budget::max_total_tokens() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.Budget.max_total_tokens)
  return _internal_max_total_tokens();
}
inline void Budget::_internal_set_max_total_tokens(int64_t value) {
  
  _impl_.max_total_tokens_ = value;
}
inline void Budget::set_max_total_tokens(int64_t value) {
  _internal_set_max_total_tokens(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.Budget.max_total_tokens)
}

// int64 deadline_ms = 4;
inline void Budget::clear_deadline_ms() {
  _impl_.deadline_ms_ = int64_t{0};
}
inline int64_t Budget::_internal_deadline_ms() const {
  return _impl_.deadline_ms_;
}
inline int64_t Budget::deadline_ms() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.Budget.deadline_ms)
  return _internal_deadline_ms();
}
inline void Budget::_internal_set_deadline_ms(int64_t value) {
  
  _impl_.deadline_ms_ = value;
}
inline void Budget::set_deadline_ms(int64_t value) {
  _internal_set_deadline_ms(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.Budget.deadline_ms)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// JobMetadata

// string tenant_id = 1;
inline void JobMetadata::clear_tenant_id() {
  _impl_.tenant_id_.ClearToEmpty();
}
inline const std::string& JobMetadata::tenant_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobMetadata.tenant_id)
  return _internal_tenant_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobMetadata::set_tenant_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tenant_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobMetadata.tenant_id)
}
inline std::string* JobMetadata::mutable_tenant_id() {
  std::string* _s = _internal_mutable_tenant_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobMetadata.tenant_id)
  return _s;
}
inline const std::string& JobMetadata::_internal_tenant_id() const {
  return _impl_.tenant_id_.Get();
}
inline void JobMetadata::_internal_set_tenant_id(const std::string& value) {
  
  _impl_.tenant_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobMetadata::_internal_mutable_tenant_id() {
  
  return _impl_.tenant_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobMetadata::release_tenant_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobMetadata.tenant_id)
  return _impl_.tenant_id_.Release();
}
inline void JobMetadata::set_allocated_tenant_id(std::string* tenant_id) {
  if (tenant_id != nullptr) {
    
  } else {
    
  }
  _impl_.tenant_id_.SetAllocated(tenant_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tenant_id_.IsDefault()) {
    _impl_.tenant_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobMetadata.tenant_id)
}

// string actor_id = 2;
inline void JobMetadata::clear_actor_id() {
  _impl_.actor_id_.ClearToEmpty();
}
inline const std::string& JobMetadata::actor_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobMetadata.actor_id)
  return _internal_actor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobMetadata::set_actor_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.actor_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobMetadata.actor_id)
}
inline std::string* JobMetadata::mutable_actor_id() {
  std::string* _s = _internal_mutable_actor_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobMetadata.actor_id)
  return _s;
}
inline const std::string& JobMetadata::_internal_actor_id() const {
  return _impl_.actor_id_.Get();
}
inline void JobMetadata::_internal_set_actor_id(const std::string& value) {
  
  _impl_.actor_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobMetadata::_internal_mutable_actor_id() {
  
  return _impl_.actor_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobMetadata::release_actor_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobMetadata.actor_id)
  return _impl_.actor_id_.Release();
}
inline void JobMetadata::set_allocated_actor_id(std::string* actor_id) {
  if (actor_id != nullptr) {
    
  } else {
    
  }
  _impl_.actor_id_.SetAllocated(actor_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.actor_id_.IsDefault()) {
    _impl_.actor_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobMetadata.actor_id)
}

// .cordum.agent.v1.ActorType actor_type = 3;
inline void JobMetadata::clear_actor_type() {
  _impl_.actor_type_ = 0;
}
inline ::cordum::agent::v1::ActorType JobMetadata::_internal_actor_type() const {
  return static_cast< ::cordum::agent::v1::ActorType >(_impl_.actor_type_);
}
inline ::cordum::agent::v1::ActorType JobMetadata::actor_type() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobMetadata.actor_type)
  return _internal_actor_type();
}
inline void JobMetadata::_internal_set_actor_type(::cordum::agent::v1::ActorType value) {
  
  _impl_.actor_type_ = value;
}
inline void JobMetadata::set_actor_type(::cordum::agent::v1::ActorType value) {
  _internal_set_actor_type(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobMetadata.actor_type)
}

// string idempotency_key = 4;
inline void JobMetadata::clear_idempotency_key() {
  _impl_.idempotency_key_.ClearToEmpty();
}
inline const std::string& JobMetadata::idempotency_key() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobMetadata.idempotency_key)
  return _internal_idempotency_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobMetadata::set_idempotency_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.idempotency_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobMetadata.idempotency_key)
}
inline std::string* JobMetadata::mutable_idempotency_key() {
  std::string* _s = _internal_mutable_idempotency_key();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobMetadata.idempotency_key)
  return _s;
}
inline const std::string& JobMetadata::_internal_idempotency_key() const {
  return _impl_.idempotency_key_.Get();
}
inline void JobMetadata::_internal_set_idempotency_key(const std::string& value) {
  
  _impl_.idempotency_key_.Set(value, GetArenaForAllocation());
}
inline std::string* JobMetadata::_internal_mutable_idempotency_key() {
  
  return _impl_.idempotency_key_.Mutable(GetArenaForAllocation());
}
inline std::string* JobMetadata::release_idempotency_key() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobMetadata.idempotency_key)
  return _impl_.idempotency_key_.Release();
}
inline void JobMetadata::set_allocated_idempotency_key(std::string* idempotency_key) {
  if (idempotency_key != nullptr) {
    
  } else {
    
  }
  _impl_.idempotency_key_.SetAllocated(idempotency_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.idempotency_key_.IsDefault()) {
    _impl_.idempotency_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobMetadata.idempotency_key)
}

// string capability = 5;
inline void JobMetadata::clear_capability() {
  _impl_.capability_.ClearToEmpty();
}
inline const std::string& JobMetadata::capability() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobMetadata.capability)
  return _internal_capability();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobMetadata::set_capability(ArgT0&& arg0, ArgT... args) {
 
 _impl_.capability_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobMetadata.capability)
}
inline std::string* JobMetadata::mutable_capability() {
  std::string* _s = _internal_mutable_capability();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobMetadata.capability)
  return _s;
}
inline const std::string& JobMetadata::_internal_capability() const {
  return _impl_.capability_.Get();
}
inline void JobMetadata::_internal_set_capability(const std::string& value) {
  
  _impl_.capability_.Set(value, GetArenaForAllocation());
}
inline std::string* JobMetadata::_internal_mutable_capability() {
  
  return _impl_.capability_.Mutable(GetArenaForAllocation());
}
inline std::string* JobMetadata::release_capability() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobMetadata.capability)
  return _impl_.capability_.Release();
}
inline void JobMetadata::set_allocated_capability(std::string* capability) {
  if (capability != nullptr) {
    
  } else {
    
  }
  _impl_.capability_.SetAllocated(capability, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.capability_.IsDefault()) {
    _impl_.capability_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobMetadata.capability)
}

// repeated string risk_tags = 6;
inline int JobMetadata::_internal_risk_tags_size() const {
  return _impl_.risk_tags_.size();
}
inline int JobMetadata::risk_tags_size() const {
  return _internal_risk_tags_size();
}
inline void JobMetadata::clear_risk_tags() {
  _impl_.risk_tags_.Clear();
}
inline std::string* JobMetadata::add_risk_tags() {
  std::string* _s = _internal_add_risk_tags();
  // @@protoc_insertion_point(field_add_mutable:cordum.agent.v1.JobMetadata.risk_tags)
  return _s;
}
inline const std::string& JobMetadata::_internal_risk_tags(int index) const {
  return _impl_.risk_tags_.Get(index);
}
inline const std::string& JobMetadata::risk_tags(int index) const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobMetadata.risk_tags)
  return _internal_risk_tags(index);
}
inline std::string* JobMetadata::mutable_risk_tags(int index) {
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobMetadata.risk_tags)
  return _impl_.risk_tags_.Mutable(index);
}
inline void JobMetadata::set_risk_tags(int index, const std::string& value) {
  _impl_.risk_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobMetadata.risk_tags)
}
inline void JobMetadata::set_risk_tags(int index, std::string&& value) {
  _impl_.risk_tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobMetadata.risk_tags)
}
inline void JobMetadata::set_risk_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.risk_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cordum.agent.v1.JobMetadata.risk_tags)
}
inline void JobMetadata::set_risk_tags(int index, const char* value, size_t size) {
  _impl_.risk_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cordum.agent.v1.JobMetadata.risk_tags)
}
inline std::string* JobMetadata::_internal_add_risk_tags() {
  return _impl_.risk_tags_.Add();
}
inline void JobMetadata::add_risk_tags(const std::string& value) {
  _impl_.risk_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cordum.agent.v1.JobMetadata.risk_tags)
}
inline void JobMetadata::add_risk_tags(std::string&& value) {
  _impl_.risk_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cordum.agent.v1.JobMetadata.risk_tags)
}
inline void JobMetadata::add_risk_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.risk_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cordum.agent.v1.JobMetadata.risk_tags)
}
inline void JobMetadata::add_risk_tags(const char* value, size_t size) {
  _impl_.risk_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cordum.agent.v1.JobMetadata.risk_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JobMetadata::risk_tags() const {
  // @@protoc_insertion_point(field_list:cordum.agent.v1.JobMetadata.risk_tags)
  return _impl_.risk_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JobMetadata::mutable_risk_tags() {
  // @@protoc_insertion_point(field_mutable_list:cordum.agent.v1.JobMetadata.risk_tags)
  return &_impl_.risk_tags_;
}

// repeated string requires = 7;
inline int JobMetadata::_internal_requires_size() const {
  return _impl_.requires_.size();
}
inline int JobMetadata::requires_size() const {
  return _internal_requires_size();
}
inline void JobMetadata::clear_requires() {
  _impl_.requires_.Clear();
}
inline std::string* JobMetadata::add_requires() {
  std::string* _s = _internal_add_requires();
  // @@protoc_insertion_point(field_add_mutable:cordum.agent.v1.JobMetadata.requires)
  return _s;
}
inline const std::string& JobMetadata::_internal_requires(int index) const {
  return _impl_.requires_.Get(index);
}
inline const std::string& JobMetadata::requires(int index) const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobMetadata.requires)
  return _internal_requires(index);
}
inline std::string* JobMetadata::mutable_requires(int index) {
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobMetadata.requires)
  return _impl_.requires_.Mutable(index);
}
inline void JobMetadata::set_requires(int index, const std::string& value) {
  _impl_.requires_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobMetadata.requires)
}
inline void JobMetadata::set_requires(int index, std::string&& value) {
  _impl_.requires_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobMetadata.requires)
}
inline void JobMetadata::set_requires(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.requires_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cordum.agent.v1.JobMetadata.requires)
}
inline void JobMetadata::set_requires(int index, const char* value, size_t size) {
  _impl_.requires_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cordum.agent.v1.JobMetadata.requires)
}
inline std::string* JobMetadata::_internal_add_requires() {
  return _impl_.requires_.Add();
}
inline void JobMetadata::add_requires(const std::string& value) {
  _impl_.requires_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cordum.agent.v1.JobMetadata.requires)
}
inline void JobMetadata::add_requires(std::string&& value) {
  _impl_.requires_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cordum.agent.v1.JobMetadata.requires)
}
inline void JobMetadata::add_requires(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.requires_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cordum.agent.v1.JobMetadata.requires)
}
inline void JobMetadata::add_requires(const char* value, size_t size) {
  _impl_.requires_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cordum.agent.v1.JobMetadata.requires)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JobMetadata::requires() const {
  // @@protoc_insertion_point(field_list:cordum.agent.v1.JobMetadata.requires)
  return _impl_.requires_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JobMetadata::mutable_requires() {
  // @@protoc_insertion_point(field_mutable_list:cordum.agent.v1.JobMetadata.requires)
  return &_impl_.requires_;
}

// string pack_id = 8;
inline void JobMetadata::clear_pack_id() {
  _impl_.pack_id_.ClearToEmpty();
}
inline const std::string& JobMetadata::pack_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobMetadata.pack_id)
  return _internal_pack_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobMetadata::set_pack_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pack_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobMetadata.pack_id)
}
inline std::string* JobMetadata::mutable_pack_id() {
  std::string* _s = _internal_mutable_pack_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobMetadata.pack_id)
  return _s;
}
inline const std::string& JobMetadata::_internal_pack_id() const {
  return _impl_.pack_id_.Get();
}
inline void JobMetadata::_internal_set_pack_id(const std::string& value) {
  
  _impl_.pack_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobMetadata::_internal_mutable_pack_id() {
  
  return _impl_.pack_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobMetadata::release_pack_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobMetadata.pack_id)
  return _impl_.pack_id_.Release();
}
inline void JobMetadata::set_allocated_pack_id(std::string* pack_id) {
  if (pack_id != nullptr) {
    
  } else {
    
  }
  _impl_.pack_id_.SetAllocated(pack_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pack_id_.IsDefault()) {
    _impl_.pack_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobMetadata.pack_id)
}

// map<string, string> labels = 9;
inline int JobMetadata::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int JobMetadata::labels_size() const {
  return _internal_labels_size();
}
inline void JobMetadata::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobMetadata::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobMetadata::labels() const {
  // @@protoc_insertion_point(field_map:cordum.agent.v1.JobMetadata.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobMetadata::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobMetadata::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:cordum.agent.v1.JobMetadata.labels)
  return _internal_mutable_labels();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// JobRequest

// string job_id = 1;
inline void JobRequest::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& JobRequest::job_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.job_id)
}
inline std::string* JobRequest::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.job_id)
  return _s;
}
inline const std::string& JobRequest::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void JobRequest::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_job_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.job_id)
  return _impl_.job_id_.Release();
}
inline void JobRequest::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.job_id)
}

// string topic = 2;
inline void JobRequest::clear_topic() {
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& JobRequest::topic() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_topic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.topic)
}
inline std::string* JobRequest::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.topic)
  return _s;
}
inline const std::string& JobRequest::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void JobRequest::_internal_set_topic(const std::string& value) {
  
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_topic() {
  
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_topic() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.topic)
  return _impl_.topic_.Release();
}
inline void JobRequest::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.topic)
}

// .cordum.agent.v1.JobPriority priority = 3;
inline void JobRequest::clear_priority() {
  _impl_.priority_ = 0;
}
inline ::cordum::agent::v1::JobPriority JobRequest::_internal_priority() const {
  return static_cast< ::cordum::agent::v1::JobPriority >(_impl_.priority_);
}
inline ::cordum::agent::v1::JobPriority JobRequest::priority() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.priority)
  return _internal_priority();
}
inline void JobRequest::_internal_set_priority(::cordum::agent::v1::JobPriority value) {
  
  _impl_.priority_ = value;
}
inline void JobRequest::set_priority(::cordum::agent::v1::JobPriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.priority)
}

// string context_ptr = 4;
inline void JobRequest::clear_context_ptr() {
  _impl_.context_ptr_.ClearToEmpty();
}
inline const std::string& JobRequest::context_ptr() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.context_ptr)
  return _internal_context_ptr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_context_ptr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.context_ptr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.context_ptr)
}
inline std::string* JobRequest::mutable_context_ptr() {
  std::string* _s = _internal_mutable_context_ptr();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.context_ptr)
  return _s;
}
inline const std::string& JobRequest::_internal_context_ptr() const {
  return _impl_.context_ptr_.Get();
}
inline void JobRequest::_internal_set_context_ptr(const std::string& value) {
  
  _impl_.context_ptr_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_context_ptr() {
  
  return _impl_.context_ptr_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_context_ptr() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.context_ptr)
  return _impl_.context_ptr_.Release();
}
inline void JobRequest::set_allocated_context_ptr(std::string* context_ptr) {
  if (context_ptr != nullptr) {
    
  } else {
    
  }
  _impl_.context_ptr_.SetAllocated(context_ptr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.context_ptr_.IsDefault()) {
    _impl_.context_ptr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.context_ptr)
}

// string adapter_id = 5;
inline void JobRequest::clear_adapter_id() {
  _impl_.adapter_id_.ClearToEmpty();
}
inline const std::string& JobRequest::adapter_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.adapter_id)
  return _internal_adapter_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_adapter_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.adapter_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.adapter_id)
}
inline std::string* JobRequest::mutable_adapter_id() {
  std::string* _s = _internal_mutable_adapter_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.adapter_id)
  return _s;
}
inline const std::string& JobRequest::_internal_adapter_id() const {
  return _impl_.adapter_id_.Get();
}
inline void JobRequest::_internal_set_adapter_id(const std::string& value) {
  
  _impl_.adapter_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_adapter_id() {
  
  return _impl_.adapter_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_adapter_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.adapter_id)
  return _impl_.adapter_id_.Release();
}
inline void JobRequest::set_allocated_adapter_id(std::string* adapter_id) {
  if (adapter_id != nullptr) {
    
  } else {
    
  }
  _impl_.adapter_id_.SetAllocated(adapter_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.adapter_id_.IsDefault()) {
    _impl_.adapter_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.adapter_id)
}

// map<string, string> env = 6;
inline int JobRequest::_internal_env_size() const {
  return _impl_.env_.size();
}
inline int JobRequest::env_size() const {
  return _internal_env_size();
}
inline void JobRequest::clear_env() {
  _impl_.env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobRequest::_internal_env() const {
  return _impl_.env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobRequest::env() const {
  // @@protoc_insertion_point(field_map:cordum.agent.v1.JobRequest.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobRequest::_internal_mutable_env() {
  return _impl_.env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobRequest::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:cordum.agent.v1.JobRequest.env)
  return _internal_mutable_env();
}

// string parent_job_id = 7;
inline void JobRequest::clear_parent_job_id() {
  _impl_.parent_job_id_.ClearToEmpty();
}
inline const std::string& JobRequest::parent_job_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.parent_job_id)
  return _internal_parent_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_parent_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.parent_job_id)
}
inline std::string* JobRequest::mutable_parent_job_id() {
  std::string* _s = _internal_mutable_parent_job_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.parent_job_id)
  return _s;
}
inline const std::string& JobRequest::_internal_parent_job_id() const {
  return _impl_.parent_job_id_.Get();
}
inline void JobRequest::_internal_set_parent_job_id(const std::string& value) {
  
  _impl_.parent_job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_parent_job_id() {
  
  return _impl_.parent_job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_parent_job_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.parent_job_id)
  return _impl_.parent_job_id_.Release();
}
inline void JobRequest::set_allocated_parent_job_id(std::string* parent_job_id) {
  if (parent_job_id != nullptr) {
    
  } else {
    
  }
  _impl_.parent_job_id_.SetAllocated(parent_job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_job_id_.IsDefault()) {
    _impl_.parent_job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.parent_job_id)
}

// string workflow_id = 8;
inline void JobRequest::clear_workflow_id() {
  _impl_.workflow_id_.ClearToEmpty();
}
inline const std::string& JobRequest::workflow_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.workflow_id)
  return _internal_workflow_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_workflow_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.workflow_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.workflow_id)
}
inline std::string* JobRequest::mutable_workflow_id() {
  std::string* _s = _internal_mutable_workflow_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.workflow_id)
  return _s;
}
inline const std::string& JobRequest::_internal_workflow_id() const {
  return _impl_.workflow_id_.Get();
}
inline void JobRequest::_internal_set_workflow_id(const std::string& value) {
  
  _impl_.workflow_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_workflow_id() {
  
  return _impl_.workflow_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_workflow_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.workflow_id)
  return _impl_.workflow_id_.Release();
}
inline void JobRequest::set_allocated_workflow_id(std::string* workflow_id) {
  if (workflow_id != nullptr) {
    
  } else {
    
  }
  _impl_.workflow_id_.SetAllocated(workflow_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.workflow_id_.IsDefault()) {
    _impl_.workflow_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.workflow_id)
}

// int32 step_index = 9;
inline void JobRequest::clear_step_index() {
  _impl_.step_index_ = 0;
}
inline int32_t JobRequest::_internal_step_index() const {
  return _impl_.step_index_;
}
inline int32_t JobRequest::step_index() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.step_index)
  return _internal_step_index();
}
inline void JobRequest::_internal_set_step_index(int32_t value) {
  
  _impl_.step_index_ = value;
}
inline void JobRequest::set_step_index(int32_t value) {
  _internal_set_step_index(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.step_index)
}

// string memory_id = 10;
inline void JobRequest::clear_memory_id() {
  _impl_.memory_id_.ClearToEmpty();
}
inline const std::string& JobRequest::memory_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.memory_id)
  return _internal_memory_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_memory_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.memory_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.memory_id)
}
inline std::string* JobRequest::mutable_memory_id() {
  std::string* _s = _internal_mutable_memory_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.memory_id)
  return _s;
}
inline const std::string& JobRequest::_internal_memory_id() const {
  return _impl_.memory_id_.Get();
}
inline void JobRequest::_internal_set_memory_id(const std::string& value) {
  
  _impl_.memory_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_memory_id() {
  
  return _impl_.memory_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_memory_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.memory_id)
  return _impl_.memory_id_.Release();
}
inline void JobRequest::set_allocated_memory_id(std::string* memory_id) {
  if (memory_id != nullptr) {
    
  } else {
    
  }
  _impl_.memory_id_.SetAllocated(memory_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memory_id_.IsDefault()) {
    _impl_.memory_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.memory_id)
}

// .cordum.agent.v1.ContextHints context_hints = 11;
inline bool JobRequest::_internal_has_context_hints() const {
  return this != internal_default_instance() && _impl_.context_hints_ != nullptr;
}
inline bool JobRequest::has_context_hints() const {
  return _internal_has_context_hints();
}
inline void JobRequest::clear_context_hints() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_hints_ != nullptr) {
    delete _impl_.context_hints_;
  }
  _impl_.context_hints_ = nullptr;
}
inline const ::cordum::agent::v1::ContextHints& JobRequest::_internal_context_hints() const {
  const ::cordum::agent::v1::ContextHints* p = _impl_.context_hints_;
  return p != nullptr ? *p : reinterpret_cast<const ::cordum::agent::v1::ContextHints&>(
      ::cordum::agent::v1::_ContextHints_default_instance_);
}
inline const ::cordum::agent::v1::ContextHints& JobRequest::context_hints() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.context_hints)
  return _internal_context_hints();
}
inline void JobRequest::unsafe_arena_set_allocated_context_hints(
    ::cordum::agent::v1::ContextHints* context_hints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_hints_);
  }
  _impl_.context_hints_ = context_hints;
  if (context_hints) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cordum.agent.v1.JobRequest.context_hints)
}
inline ::cordum::agent::v1::ContextHints* JobRequest::release_context_hints() {
  
  ::cordum::agent::v1::ContextHints* temp = _impl_.context_hints_;
  _impl_.context_hints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cordum::agent::v1::ContextHints* JobRequest::unsafe_arena_release_context_hints() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.context_hints)
  
  ::cordum::agent::v1::ContextHints* temp = _impl_.context_hints_;
  _impl_.context_hints_ = nullptr;
  return temp;
}
inline ::cordum::agent::v1::ContextHints* JobRequest::_internal_mutable_context_hints() {
  
  if (_impl_.context_hints_ == nullptr) {
    auto* p = CreateMaybeMessage<::cordum::agent::v1::ContextHints>(GetArenaForAllocation());
    _impl_.context_hints_ = p;
  }
  return _impl_.context_hints_;
}
inline ::cordum::agent::v1::ContextHints* JobRequest::mutable_context_hints() {
  ::cordum::agent::v1::ContextHints* _msg = _internal_mutable_context_hints();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.context_hints)
  return _msg;
}
inline void JobRequest::set_allocated_context_hints(::cordum::agent::v1::ContextHints* context_hints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_hints_;
  }
  if (context_hints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context_hints);
    if (message_arena != submessage_arena) {
      context_hints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context_hints, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_hints_ = context_hints;
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.context_hints)
}

// .cordum.agent.v1.Budget budget = 12;
inline bool JobRequest::_internal_has_budget() const {
  return this != internal_default_instance() && _impl_.budget_ != nullptr;
}
inline bool JobRequest::has_budget() const {
  return _internal_has_budget();
}
inline void JobRequest::clear_budget() {
  if (GetArenaForAllocation() == nullptr && _impl_.budget_ != nullptr) {
    delete _impl_.budget_;
  }
  _impl_.budget_ = nullptr;
}
inline const ::cordum::agent::v1::Budget& JobRequest::_internal_budget() const {
  const ::cordum::agent::v1::Budget* p = _impl_.budget_;
  return p != nullptr ? *p : reinterpret_cast<const ::cordum::agent::v1::Budget&>(
      ::cordum::agent::v1::_Budget_default_instance_);
}
inline const ::cordum::agent::v1::Budget& JobRequest::budget() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.budget)
  return _internal_budget();
}
inline void JobRequest::unsafe_arena_set_allocated_budget(
    ::cordum::agent::v1::Budget* budget) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.budget_);
  }
  _impl_.budget_ = budget;
  if (budget) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cordum.agent.v1.JobRequest.budget)
}
inline ::cordum::agent::v1::Budget* JobRequest::release_budget() {
  
  ::cordum::agent::v1::Budget* temp = _impl_.budget_;
  _impl_.budget_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cordum::agent::v1::Budget* JobRequest::unsafe_arena_release_budget() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.budget)
  
  ::cordum::agent::v1::Budget* temp = _impl_.budget_;
  _impl_.budget_ = nullptr;
  return temp;
}
inline ::cordum::agent::v1::Budget* JobRequest::_internal_mutable_budget() {
  
  if (_impl_.budget_ == nullptr) {
    auto* p = CreateMaybeMessage<::cordum::agent::v1::Budget>(GetArenaForAllocation());
    _impl_.budget_ = p;
  }
  return _impl_.budget_;
}
inline ::cordum::agent::v1::Budget* JobRequest::mutable_budget() {
  ::cordum::agent::v1::Budget* _msg = _internal_mutable_budget();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.budget)
  return _msg;
}
inline void JobRequest::set_allocated_budget(::cordum::agent::v1::Budget* budget) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.budget_;
  }
  if (budget) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(budget);
    if (message_arena != submessage_arena) {
      budget = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, budget, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.budget_ = budget;
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.budget)
}

// string tenant_id = 13;
inline void JobRequest::clear_tenant_id() {
  _impl_.tenant_id_.ClearToEmpty();
}
inline const std::string& JobRequest::tenant_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.tenant_id)
  return _internal_tenant_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_tenant_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tenant_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.tenant_id)
}
inline std::string* JobRequest::mutable_tenant_id() {
  std::string* _s = _internal_mutable_tenant_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.tenant_id)
  return _s;
}
inline const std::string& JobRequest::_internal_tenant_id() const {
  return _impl_.tenant_id_.Get();
}
inline void JobRequest::_internal_set_tenant_id(const std::string& value) {
  
  _impl_.tenant_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_tenant_id() {
  
  return _impl_.tenant_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_tenant_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.tenant_id)
  return _impl_.tenant_id_.Release();
}
inline void JobRequest::set_allocated_tenant_id(std::string* tenant_id) {
  if (tenant_id != nullptr) {
    
  } else {
    
  }
  _impl_.tenant_id_.SetAllocated(tenant_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tenant_id_.IsDefault()) {
    _impl_.tenant_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.tenant_id)
}

// string principal_id = 14;
inline void JobRequest::clear_principal_id() {
  _impl_.principal_id_.ClearToEmpty();
}
inline const std::string& JobRequest::principal_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.principal_id)
  return _internal_principal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_principal_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.principal_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobRequest.principal_id)
}
inline std::string* JobRequest::mutable_principal_id() {
  std::string* _s = _internal_mutable_principal_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.principal_id)
  return _s;
}
inline const std::string& JobRequest::_internal_principal_id() const {
  return _impl_.principal_id_.Get();
}
inline void JobRequest::_internal_set_principal_id(const std::string& value) {
  
  _impl_.principal_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_principal_id() {
  
  return _impl_.principal_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_principal_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.principal_id)
  return _impl_.principal_id_.Release();
}
inline void JobRequest::set_allocated_principal_id(std::string* principal_id) {
  if (principal_id != nullptr) {
    
  } else {
    
  }
  _impl_.principal_id_.SetAllocated(principal_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.principal_id_.IsDefault()) {
    _impl_.principal_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.principal_id)
}

// map<string, string> labels = 15;
inline int JobRequest::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int JobRequest::labels_size() const {
  return _internal_labels_size();
}
inline void JobRequest::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobRequest::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobRequest::labels() const {
  // @@protoc_insertion_point(field_map:cordum.agent.v1.JobRequest.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobRequest::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobRequest::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:cordum.agent.v1.JobRequest.labels)
  return _internal_mutable_labels();
}

// .cordum.agent.v1.JobMetadata meta = 16;
inline bool JobRequest::_internal_has_meta() const {
  return this != internal_default_instance() && _impl_.meta_ != nullptr;
}
inline bool JobRequest::has_meta() const {
  return _internal_has_meta();
}
inline void JobRequest::clear_meta() {
  if (GetArenaForAllocation() == nullptr && _impl_.meta_ != nullptr) {
    delete _impl_.meta_;
  }
  _impl_.meta_ = nullptr;
}
inline const ::cordum::agent::v1::JobMetadata& JobRequest::_internal_meta() const {
  const ::cordum::agent::v1::JobMetadata* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::cordum::agent::v1::JobMetadata&>(
      ::cordum::agent::v1::_JobMetadata_default_instance_);
}
inline const ::cordum::agent::v1::JobMetadata& JobRequest::meta() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobRequest.meta)
  return _internal_meta();
}
inline void JobRequest::unsafe_arena_set_allocated_meta(
    ::cordum::agent::v1::JobMetadata* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cordum.agent.v1.JobRequest.meta)
}
inline ::cordum::agent::v1::JobMetadata* JobRequest::release_meta() {
  
  ::cordum::agent::v1::JobMetadata* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cordum::agent::v1::JobMetadata* JobRequest::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobRequest.meta)
  
  ::cordum::agent::v1::JobMetadata* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::cordum::agent::v1::JobMetadata* JobRequest::_internal_mutable_meta() {
  
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::cordum::agent::v1::JobMetadata>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::cordum::agent::v1::JobMetadata* JobRequest::mutable_meta() {
  ::cordum::agent::v1::JobMetadata* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobRequest.meta)
  return _msg;
}
inline void JobRequest::set_allocated_meta(::cordum::agent::v1::JobMetadata* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobRequest.meta)
}

// -------------------------------------------------------------------

// JobResult

// string job_id = 1;
inline void JobResult::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& JobResult::job_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobResult.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobResult::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobResult.job_id)
}
inline std::string* JobResult::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobResult.job_id)
  return _s;
}
inline const std::string& JobResult::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void JobResult::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobResult::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobResult::release_job_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobResult.job_id)
  return _impl_.job_id_.Release();
}
inline void JobResult::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobResult.job_id)
}

// .cordum.agent.v1.JobStatus status = 2;
inline void JobResult::clear_status() {
  _impl_.status_ = 0;
}
inline ::cordum::agent::v1::JobStatus JobResult::_internal_status() const {
  return static_cast< ::cordum::agent::v1::JobStatus >(_impl_.status_);
}
inline ::cordum::agent::v1::JobStatus JobResult::status() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobResult.status)
  return _internal_status();
}
inline void JobResult::_internal_set_status(::cordum::agent::v1::JobStatus value) {
  
  _impl_.status_ = value;
}
inline void JobResult::set_status(::cordum::agent::v1::JobStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobResult.status)
}

// string result_ptr = 3;
inline void JobResult::clear_result_ptr() {
  _impl_.result_ptr_.ClearToEmpty();
}
inline const std::string& JobResult::result_ptr() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobResult.result_ptr)
  return _internal_result_ptr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobResult::set_result_ptr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_ptr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobResult.result_ptr)
}
inline std::string* JobResult::mutable_result_ptr() {
  std::string* _s = _internal_mutable_result_ptr();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobResult.result_ptr)
  return _s;
}
inline const std::string& JobResult::_internal_result_ptr() const {
  return _impl_.result_ptr_.Get();
}
inline void JobResult::_internal_set_result_ptr(const std::string& value) {
  
  _impl_.result_ptr_.Set(value, GetArenaForAllocation());
}
inline std::string* JobResult::_internal_mutable_result_ptr() {
  
  return _impl_.result_ptr_.Mutable(GetArenaForAllocation());
}
inline std::string* JobResult::release_result_ptr() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobResult.result_ptr)
  return _impl_.result_ptr_.Release();
}
inline void JobResult::set_allocated_result_ptr(std::string* result_ptr) {
  if (result_ptr != nullptr) {
    
  } else {
    
  }
  _impl_.result_ptr_.SetAllocated(result_ptr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_ptr_.IsDefault()) {
    _impl_.result_ptr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobResult.result_ptr)
}

// string worker_id = 4;
inline void JobResult::clear_worker_id() {
  _impl_.worker_id_.ClearToEmpty();
}
inline const std::string& JobResult::worker_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobResult.worker_id)
  return _internal_worker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobResult::set_worker_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.worker_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobResult.worker_id)
}
inline std::string* JobResult::mutable_worker_id() {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobResult.worker_id)
  return _s;
}
inline const std::string& JobResult::_internal_worker_id() const {
  return _impl_.worker_id_.Get();
}
inline void JobResult::_internal_set_worker_id(const std::string& value) {
  
  _impl_.worker_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobResult::_internal_mutable_worker_id() {
  
  return _impl_.worker_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobResult::release_worker_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobResult.worker_id)
  return _impl_.worker_id_.Release();
}
inline void JobResult::set_allocated_worker_id(std::string* worker_id) {
  if (worker_id != nullptr) {
    
  } else {
    
  }
  _impl_.worker_id_.SetAllocated(worker_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.worker_id_.IsDefault()) {
    _impl_.worker_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobResult.worker_id)
}

// int64 execution_ms = 5;
inline void JobResult::clear_execution_ms() {
  _impl_.execution_ms_ = int64_t{0};
}
inline int64_t JobResult::_internal_execution_ms() const {
  return _impl_.execution_ms_;
}
inline int64_t JobResult::execution_ms() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobResult.execution_ms)
  return _internal_execution_ms();
}
inline void JobResult::_internal_set_execution_ms(int64_t value) {
  
  _impl_.execution_ms_ = value;
}
inline void JobResult::set_execution_ms(int64_t value) {
  _internal_set_execution_ms(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobResult.execution_ms)
}

// string error_code = 6;
inline void JobResult::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& JobResult::error_code() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobResult.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobResult::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobResult.error_code)
}
inline std::string* JobResult::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobResult.error_code)
  return _s;
}
inline const std::string& JobResult::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void JobResult::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* JobResult::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* JobResult::release_error_code() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobResult.error_code)
  return _impl_.error_code_.Release();
}
inline void JobResult::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobResult.error_code)
}

// string error_message = 7;
inline void JobResult::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& JobResult::error_message() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobResult.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobResult::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobResult.error_message)
}
inline std::string* JobResult::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobResult.error_message)
  return _s;
}
inline const std::string& JobResult::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void JobResult::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* JobResult::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* JobResult::release_error_message() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobResult.error_message)
  return _impl_.error_message_.Release();
}
inline void JobResult::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobResult.error_message)
}

// repeated string artifact_ptrs = 8;
inline int JobResult::_internal_artifact_ptrs_size() const {
  return _impl_.artifact_ptrs_.size();
}
inline int JobResult::artifact_ptrs_size() const {
  return _internal_artifact_ptrs_size();
}
inline void JobResult::clear_artifact_ptrs() {
  _impl_.artifact_ptrs_.Clear();
}
inline std::string* JobResult::add_artifact_ptrs() {
  std::string* _s = _internal_add_artifact_ptrs();
  // @@protoc_insertion_point(field_add_mutable:cordum.agent.v1.JobResult.artifact_ptrs)
  return _s;
}
inline const std::string& JobResult::_internal_artifact_ptrs(int index) const {
  return _impl_.artifact_ptrs_.Get(index);
}
inline const std::string& JobResult::artifact_ptrs(int index) const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobResult.artifact_ptrs)
  return _internal_artifact_ptrs(index);
}
inline std::string* JobResult::mutable_artifact_ptrs(int index) {
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobResult.artifact_ptrs)
  return _impl_.artifact_ptrs_.Mutable(index);
}
inline void JobResult::set_artifact_ptrs(int index, const std::string& value) {
  _impl_.artifact_ptrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobResult.artifact_ptrs)
}
inline void JobResult::set_artifact_ptrs(int index, std::string&& value) {
  _impl_.artifact_ptrs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobResult.artifact_ptrs)
}
inline void JobResult::set_artifact_ptrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.artifact_ptrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cordum.agent.v1.JobResult.artifact_ptrs)
}
inline void JobResult::set_artifact_ptrs(int index, const char* value, size_t size) {
  _impl_.artifact_ptrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cordum.agent.v1.JobResult.artifact_ptrs)
}
inline std::string* JobResult::_internal_add_artifact_ptrs() {
  return _impl_.artifact_ptrs_.Add();
}
inline void JobResult::add_artifact_ptrs(const std::string& value) {
  _impl_.artifact_ptrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cordum.agent.v1.JobResult.artifact_ptrs)
}
inline void JobResult::add_artifact_ptrs(std::string&& value) {
  _impl_.artifact_ptrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cordum.agent.v1.JobResult.artifact_ptrs)
}
inline void JobResult::add_artifact_ptrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.artifact_ptrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cordum.agent.v1.JobResult.artifact_ptrs)
}
inline void JobResult::add_artifact_ptrs(const char* value, size_t size) {
  _impl_.artifact_ptrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cordum.agent.v1.JobResult.artifact_ptrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JobResult::artifact_ptrs() const {
  // @@protoc_insertion_point(field_list:cordum.agent.v1.JobResult.artifact_ptrs)
  return _impl_.artifact_ptrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JobResult::mutable_artifact_ptrs() {
  // @@protoc_insertion_point(field_mutable_list:cordum.agent.v1.JobResult.artifact_ptrs)
  return &_impl_.artifact_ptrs_;
}

// -------------------------------------------------------------------

// JobProgress

// string job_id = 1;
inline void JobProgress::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& JobProgress::job_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobProgress.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobProgress::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobProgress.job_id)
}
inline std::string* JobProgress::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobProgress.job_id)
  return _s;
}
inline const std::string& JobProgress::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void JobProgress::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobProgress::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobProgress::release_job_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobProgress.job_id)
  return _impl_.job_id_.Release();
}
inline void JobProgress::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobProgress.job_id)
}

// string step_id = 2;
inline void JobProgress::clear_step_id() {
  _impl_.step_id_.ClearToEmpty();
}
inline const std::string& JobProgress::step_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobProgress.step_id)
  return _internal_step_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobProgress::set_step_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobProgress.step_id)
}
inline std::string* JobProgress::mutable_step_id() {
  std::string* _s = _internal_mutable_step_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobProgress.step_id)
  return _s;
}
inline const std::string& JobProgress::_internal_step_id() const {
  return _impl_.step_id_.Get();
}
inline void JobProgress::_internal_set_step_id(const std::string& value) {
  
  _impl_.step_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobProgress::_internal_mutable_step_id() {
  
  return _impl_.step_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobProgress::release_step_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobProgress.step_id)
  return _impl_.step_id_.Release();
}
inline void JobProgress::set_allocated_step_id(std::string* step_id) {
  if (step_id != nullptr) {
    
  } else {
    
  }
  _impl_.step_id_.SetAllocated(step_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_id_.IsDefault()) {
    _impl_.step_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobProgress.step_id)
}

// int32 percent = 3;
inline void JobProgress::clear_percent() {
  _impl_.percent_ = 0;
}
inline int32_t JobProgress::_internal_percent() const {
  return _impl_.percent_;
}
inline int32_t JobProgress::percent() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobProgress.percent)
  return _internal_percent();
}
inline void JobProgress::_internal_set_percent(int32_t value) {
  
  _impl_.percent_ = value;
}
inline void JobProgress::set_percent(int32_t value) {
  _internal_set_percent(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobProgress.percent)
}

// string message = 4;
inline void JobProgress::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& JobProgress::message() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobProgress.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobProgress::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobProgress.message)
}
inline std::string* JobProgress::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobProgress.message)
  return _s;
}
inline const std::string& JobProgress::_internal_message() const {
  return _impl_.message_.Get();
}
inline void JobProgress::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* JobProgress::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* JobProgress::release_message() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobProgress.message)
  return _impl_.message_.Release();
}
inline void JobProgress::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobProgress.message)
}

// string result_ptr = 5;
inline void JobProgress::clear_result_ptr() {
  _impl_.result_ptr_.ClearToEmpty();
}
inline const std::string& JobProgress::result_ptr() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobProgress.result_ptr)
  return _internal_result_ptr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobProgress::set_result_ptr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_ptr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobProgress.result_ptr)
}
inline std::string* JobProgress::mutable_result_ptr() {
  std::string* _s = _internal_mutable_result_ptr();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobProgress.result_ptr)
  return _s;
}
inline const std::string& JobProgress::_internal_result_ptr() const {
  return _impl_.result_ptr_.Get();
}
inline void JobProgress::_internal_set_result_ptr(const std::string& value) {
  
  _impl_.result_ptr_.Set(value, GetArenaForAllocation());
}
inline std::string* JobProgress::_internal_mutable_result_ptr() {
  
  return _impl_.result_ptr_.Mutable(GetArenaForAllocation());
}
inline std::string* JobProgress::release_result_ptr() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobProgress.result_ptr)
  return _impl_.result_ptr_.Release();
}
inline void JobProgress::set_allocated_result_ptr(std::string* result_ptr) {
  if (result_ptr != nullptr) {
    
  } else {
    
  }
  _impl_.result_ptr_.SetAllocated(result_ptr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_ptr_.IsDefault()) {
    _impl_.result_ptr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobProgress.result_ptr)
}

// repeated string artifact_ptrs = 6;
inline int JobProgress::_internal_artifact_ptrs_size() const {
  return _impl_.artifact_ptrs_.size();
}
inline int JobProgress::artifact_ptrs_size() const {
  return _internal_artifact_ptrs_size();
}
inline void JobProgress::clear_artifact_ptrs() {
  _impl_.artifact_ptrs_.Clear();
}
inline std::string* JobProgress::add_artifact_ptrs() {
  std::string* _s = _internal_add_artifact_ptrs();
  // @@protoc_insertion_point(field_add_mutable:cordum.agent.v1.JobProgress.artifact_ptrs)
  return _s;
}
inline const std::string& JobProgress::_internal_artifact_ptrs(int index) const {
  return _impl_.artifact_ptrs_.Get(index);
}
inline const std::string& JobProgress::artifact_ptrs(int index) const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobProgress.artifact_ptrs)
  return _internal_artifact_ptrs(index);
}
inline std::string* JobProgress::mutable_artifact_ptrs(int index) {
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobProgress.artifact_ptrs)
  return _impl_.artifact_ptrs_.Mutable(index);
}
inline void JobProgress::set_artifact_ptrs(int index, const std::string& value) {
  _impl_.artifact_ptrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobProgress.artifact_ptrs)
}
inline void JobProgress::set_artifact_ptrs(int index, std::string&& value) {
  _impl_.artifact_ptrs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobProgress.artifact_ptrs)
}
inline void JobProgress::set_artifact_ptrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.artifact_ptrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cordum.agent.v1.JobProgress.artifact_ptrs)
}
inline void JobProgress::set_artifact_ptrs(int index, const char* value, size_t size) {
  _impl_.artifact_ptrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cordum.agent.v1.JobProgress.artifact_ptrs)
}
inline std::string* JobProgress::_internal_add_artifact_ptrs() {
  return _impl_.artifact_ptrs_.Add();
}
inline void JobProgress::add_artifact_ptrs(const std::string& value) {
  _impl_.artifact_ptrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cordum.agent.v1.JobProgress.artifact_ptrs)
}
inline void JobProgress::add_artifact_ptrs(std::string&& value) {
  _impl_.artifact_ptrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cordum.agent.v1.JobProgress.artifact_ptrs)
}
inline void JobProgress::add_artifact_ptrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.artifact_ptrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cordum.agent.v1.JobProgress.artifact_ptrs)
}
inline void JobProgress::add_artifact_ptrs(const char* value, size_t size) {
  _impl_.artifact_ptrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cordum.agent.v1.JobProgress.artifact_ptrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JobProgress::artifact_ptrs() const {
  // @@protoc_insertion_point(field_list:cordum.agent.v1.JobProgress.artifact_ptrs)
  return _impl_.artifact_ptrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JobProgress::mutable_artifact_ptrs() {
  // @@protoc_insertion_point(field_mutable_list:cordum.agent.v1.JobProgress.artifact_ptrs)
  return &_impl_.artifact_ptrs_;
}

// .cordum.agent.v1.JobStatus status = 7;
inline void JobProgress::clear_status() {
  _impl_.status_ = 0;
}
inline ::cordum::agent::v1::JobStatus JobProgress::_internal_status() const {
  return static_cast< ::cordum::agent::v1::JobStatus >(_impl_.status_);
}
inline ::cordum::agent::v1::JobStatus JobProgress::status() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobProgress.status)
  return _internal_status();
}
inline void JobProgress::_internal_set_status(::cordum::agent::v1::JobStatus value) {
  
  _impl_.status_ = value;
}
inline void JobProgress::set_status(::cordum::agent::v1::JobStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobProgress.status)
}

// -------------------------------------------------------------------

// JobCancel

// string job_id = 1;
inline void JobCancel::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& JobCancel::job_id() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobCancel.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobCancel::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobCancel.job_id)
}
inline std::string* JobCancel::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobCancel.job_id)
  return _s;
}
inline const std::string& JobCancel::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void JobCancel::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobCancel::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobCancel::release_job_id() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobCancel.job_id)
  return _impl_.job_id_.Release();
}
inline void JobCancel::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobCancel.job_id)
}

// string reason = 2;
inline void JobCancel::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& JobCancel::reason() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobCancel.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobCancel::set_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobCancel.reason)
}
inline std::string* JobCancel::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobCancel.reason)
  return _s;
}
inline const std::string& JobCancel::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void JobCancel::_internal_set_reason(const std::string& value) {
  
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* JobCancel::_internal_mutable_reason() {
  
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* JobCancel::release_reason() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobCancel.reason)
  return _impl_.reason_.Release();
}
inline void JobCancel::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobCancel.reason)
}

// string requested_by = 3;
inline void JobCancel::clear_requested_by() {
  _impl_.requested_by_.ClearToEmpty();
}
inline const std::string& JobCancel::requested_by() const {
  // @@protoc_insertion_point(field_get:cordum.agent.v1.JobCancel.requested_by)
  return _internal_requested_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobCancel::set_requested_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.requested_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cordum.agent.v1.JobCancel.requested_by)
}
inline std::string* JobCancel::mutable_requested_by() {
  std::string* _s = _internal_mutable_requested_by();
  // @@protoc_insertion_point(field_mutable:cordum.agent.v1.JobCancel.requested_by)
  return _s;
}
inline const std::string& JobCancel::_internal_requested_by() const {
  return _impl_.requested_by_.Get();
}
inline void JobCancel::_internal_set_requested_by(const std::string& value) {
  
  _impl_.requested_by_.Set(value, GetArenaForAllocation());
}
inline std::string* JobCancel::_internal_mutable_requested_by() {
  
  return _impl_.requested_by_.Mutable(GetArenaForAllocation());
}
inline std::string* JobCancel::release_requested_by() {
  // @@protoc_insertion_point(field_release:cordum.agent.v1.JobCancel.requested_by)
  return _impl_.requested_by_.Release();
}
inline void JobCancel::set_allocated_requested_by(std::string* requested_by) {
  if (requested_by != nullptr) {
    
  } else {
    
  }
  _impl_.requested_by_.SetAllocated(requested_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requested_by_.IsDefault()) {
    _impl_.requested_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cordum.agent.v1.JobCancel.requested_by)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace agent
}  // namespace cordum

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::cordum::agent::v1::JobPriority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cordum::agent::v1::JobPriority>() {
  return ::cordum::agent::v1::JobPriority_descriptor();
}
template <> struct is_proto_enum< ::cordum::agent::v1::JobStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cordum::agent::v1::JobStatus>() {
  return ::cordum::agent::v1::JobStatus_descriptor();
}
template <> struct is_proto_enum< ::cordum::agent::v1::ActorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cordum::agent::v1::ActorType>() {
  return ::cordum::agent::v1::ActorType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cordum_2fagent_2fv1_2fjob_2eproto
