// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: coretex/agent/v1/job.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_coretex_2fagent_2fv1_2fjob_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_coretex_2fagent_2fv1_2fjob_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_coretex_2fagent_2fv1_2fjob_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_coretex_2fagent_2fv1_2fjob_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_coretex_2fagent_2fv1_2fjob_2eproto;
namespace coretex {
namespace agent {
namespace v1 {
class Budget;
struct BudgetDefaultTypeInternal;
extern BudgetDefaultTypeInternal _Budget_default_instance_;
class ContextHints;
struct ContextHintsDefaultTypeInternal;
extern ContextHintsDefaultTypeInternal _ContextHints_default_instance_;
class JobRequest;
struct JobRequestDefaultTypeInternal;
extern JobRequestDefaultTypeInternal _JobRequest_default_instance_;
class JobRequest_EnvEntry_DoNotUse;
struct JobRequest_EnvEntry_DoNotUseDefaultTypeInternal;
extern JobRequest_EnvEntry_DoNotUseDefaultTypeInternal _JobRequest_EnvEntry_DoNotUse_default_instance_;
class JobRequest_LabelsEntry_DoNotUse;
struct JobRequest_LabelsEntry_DoNotUseDefaultTypeInternal;
extern JobRequest_LabelsEntry_DoNotUseDefaultTypeInternal _JobRequest_LabelsEntry_DoNotUse_default_instance_;
class JobResult;
struct JobResultDefaultTypeInternal;
extern JobResultDefaultTypeInternal _JobResult_default_instance_;
}  // namespace v1
}  // namespace agent
}  // namespace coretex
PROTOBUF_NAMESPACE_OPEN
template<> ::coretex::agent::v1::Budget* Arena::CreateMaybeMessage<::coretex::agent::v1::Budget>(Arena*);
template<> ::coretex::agent::v1::ContextHints* Arena::CreateMaybeMessage<::coretex::agent::v1::ContextHints>(Arena*);
template<> ::coretex::agent::v1::JobRequest* Arena::CreateMaybeMessage<::coretex::agent::v1::JobRequest>(Arena*);
template<> ::coretex::agent::v1::JobRequest_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::coretex::agent::v1::JobRequest_EnvEntry_DoNotUse>(Arena*);
template<> ::coretex::agent::v1::JobRequest_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::coretex::agent::v1::JobRequest_LabelsEntry_DoNotUse>(Arena*);
template<> ::coretex::agent::v1::JobResult* Arena::CreateMaybeMessage<::coretex::agent::v1::JobResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace coretex {
namespace agent {
namespace v1 {

enum JobPriority : int {
  JOB_PRIORITY_UNSPECIFIED = 0,
  JOB_PRIORITY_INTERACTIVE = 1,
  JOB_PRIORITY_BATCH = 2,
  JOB_PRIORITY_CRITICAL = 3,
  JobPriority_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JobPriority_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JobPriority_IsValid(int value);
constexpr JobPriority JobPriority_MIN = JOB_PRIORITY_UNSPECIFIED;
constexpr JobPriority JobPriority_MAX = JOB_PRIORITY_CRITICAL;
constexpr int JobPriority_ARRAYSIZE = JobPriority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobPriority_descriptor();
template<typename T>
inline const std::string& JobPriority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobPriority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobPriority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobPriority_descriptor(), enum_t_value);
}
inline bool JobPriority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobPriority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobPriority>(
    JobPriority_descriptor(), name, value);
}
enum JobStatus : int {
  JOB_STATUS_UNSPECIFIED = 0,
  JOB_STATUS_PENDING = 1,
  JOB_STATUS_SCHEDULED = 2,
  JOB_STATUS_DISPATCHED = 3,
  JOB_STATUS_RUNNING = 4,
  JOB_STATUS_SUCCEEDED = 5,
  JOB_STATUS_FAILED = 6,
  JOB_STATUS_CANCELLED = 7,
  JOB_STATUS_DENIED = 8,
  JOB_STATUS_TIMEOUT = 9,
  JobStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JobStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JobStatus_IsValid(int value);
constexpr JobStatus JobStatus_MIN = JOB_STATUS_UNSPECIFIED;
constexpr JobStatus JobStatus_MAX = JOB_STATUS_TIMEOUT;
constexpr int JobStatus_ARRAYSIZE = JobStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobStatus_descriptor();
template<typename T>
inline const std::string& JobStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobStatus_descriptor(), enum_t_value);
}
inline bool JobStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobStatus>(
    JobStatus_descriptor(), name, value);
}
// ===================================================================

class ContextHints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:coretex.agent.v1.ContextHints) */ {
 public:
  inline ContextHints() : ContextHints(nullptr) {}
  ~ContextHints() override;
  explicit PROTOBUF_CONSTEXPR ContextHints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContextHints(const ContextHints& from);
  ContextHints(ContextHints&& from) noexcept
    : ContextHints() {
    *this = ::std::move(from);
  }

  inline ContextHints& operator=(const ContextHints& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextHints& operator=(ContextHints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextHints& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContextHints* internal_default_instance() {
    return reinterpret_cast<const ContextHints*>(
               &_ContextHints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ContextHints& a, ContextHints& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextHints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextHints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextHints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContextHints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContextHints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContextHints& from) {
    ContextHints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextHints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "coretex.agent.v1.ContextHints";
  }
  protected:
  explicit ContextHints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 4,
    kMaxInputTokensFieldNumber = 1,
    kAllowSummarizationFieldNumber = 2,
    kAllowRetrievalFieldNumber = 3,
  };
  // repeated string tags = 4;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // int32 max_input_tokens = 1;
  void clear_max_input_tokens();
  int32_t max_input_tokens() const;
  void set_max_input_tokens(int32_t value);
  private:
  int32_t _internal_max_input_tokens() const;
  void _internal_set_max_input_tokens(int32_t value);
  public:

  // bool allow_summarization = 2;
  void clear_allow_summarization();
  bool allow_summarization() const;
  void set_allow_summarization(bool value);
  private:
  bool _internal_allow_summarization() const;
  void _internal_set_allow_summarization(bool value);
  public:

  // bool allow_retrieval = 3;
  void clear_allow_retrieval();
  bool allow_retrieval() const;
  void set_allow_retrieval(bool value);
  private:
  bool _internal_allow_retrieval() const;
  void _internal_set_allow_retrieval(bool value);
  public:

  // @@protoc_insertion_point(class_scope:coretex.agent.v1.ContextHints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    int32_t max_input_tokens_;
    bool allow_summarization_;
    bool allow_retrieval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coretex_2fagent_2fv1_2fjob_2eproto;
};
// -------------------------------------------------------------------

class Budget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:coretex.agent.v1.Budget) */ {
 public:
  inline Budget() : Budget(nullptr) {}
  ~Budget() override;
  explicit PROTOBUF_CONSTEXPR Budget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Budget(const Budget& from);
  Budget(Budget&& from) noexcept
    : Budget() {
    *this = ::std::move(from);
  }

  inline Budget& operator=(const Budget& from) {
    CopyFrom(from);
    return *this;
  }
  inline Budget& operator=(Budget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Budget& default_instance() {
    return *internal_default_instance();
  }
  static inline const Budget* internal_default_instance() {
    return reinterpret_cast<const Budget*>(
               &_Budget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Budget& a, Budget& b) {
    a.Swap(&b);
  }
  inline void Swap(Budget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Budget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Budget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Budget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Budget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Budget& from) {
    Budget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Budget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "coretex.agent.v1.Budget";
  }
  protected:
  explicit Budget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxInputTokensFieldNumber = 1,
    kMaxOutputTokensFieldNumber = 2,
    kMaxTotalTokensFieldNumber = 3,
    kDeadlineMsFieldNumber = 4,
  };
  // int64 max_input_tokens = 1;
  void clear_max_input_tokens();
  int64_t max_input_tokens() const;
  void set_max_input_tokens(int64_t value);
  private:
  int64_t _internal_max_input_tokens() const;
  void _internal_set_max_input_tokens(int64_t value);
  public:

  // int64 max_output_tokens = 2;
  void clear_max_output_tokens();
  int64_t max_output_tokens() const;
  void set_max_output_tokens(int64_t value);
  private:
  int64_t _internal_max_output_tokens() const;
  void _internal_set_max_output_tokens(int64_t value);
  public:

  // int64 max_total_tokens = 3;
  void clear_max_total_tokens();
  int64_t max_total_tokens() const;
  void set_max_total_tokens(int64_t value);
  private:
  int64_t _internal_max_total_tokens() const;
  void _internal_set_max_total_tokens(int64_t value);
  public:

  // int64 deadline_ms = 4;
  void clear_deadline_ms();
  int64_t deadline_ms() const;
  void set_deadline_ms(int64_t value);
  private:
  int64_t _internal_deadline_ms() const;
  void _internal_set_deadline_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:coretex.agent.v1.Budget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t max_input_tokens_;
    int64_t max_output_tokens_;
    int64_t max_total_tokens_;
    int64_t deadline_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coretex_2fagent_2fv1_2fjob_2eproto;
};
// -------------------------------------------------------------------

class JobRequest_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobRequest_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobRequest_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  JobRequest_EnvEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR JobRequest_EnvEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit JobRequest_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const JobRequest_EnvEntry_DoNotUse& other);
  static const JobRequest_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const JobRequest_EnvEntry_DoNotUse*>(&_JobRequest_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "coretex.agent.v1.JobRequest.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "coretex.agent.v1.JobRequest.EnvEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_coretex_2fagent_2fv1_2fjob_2eproto;
};

// -------------------------------------------------------------------

class JobRequest_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobRequest_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobRequest_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  JobRequest_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR JobRequest_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit JobRequest_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const JobRequest_LabelsEntry_DoNotUse& other);
  static const JobRequest_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const JobRequest_LabelsEntry_DoNotUse*>(&_JobRequest_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "coretex.agent.v1.JobRequest.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "coretex.agent.v1.JobRequest.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_coretex_2fagent_2fv1_2fjob_2eproto;
};

// -------------------------------------------------------------------

class JobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:coretex.agent.v1.JobRequest) */ {
 public:
  inline JobRequest() : JobRequest(nullptr) {}
  ~JobRequest() override;
  explicit PROTOBUF_CONSTEXPR JobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobRequest(const JobRequest& from);
  JobRequest(JobRequest&& from) noexcept
    : JobRequest() {
    *this = ::std::move(from);
  }

  inline JobRequest& operator=(const JobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobRequest& operator=(JobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobRequest* internal_default_instance() {
    return reinterpret_cast<const JobRequest*>(
               &_JobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JobRequest& a, JobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobRequest& from) {
    JobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "coretex.agent.v1.JobRequest";
  }
  protected:
  explicit JobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEnvFieldNumber = 6,
    kLabelsFieldNumber = 15,
    kJobIdFieldNumber = 1,
    kTopicFieldNumber = 2,
    kContextPtrFieldNumber = 4,
    kAdapterIdFieldNumber = 5,
    kParentJobIdFieldNumber = 7,
    kWorkflowIdFieldNumber = 8,
    kMemoryIdFieldNumber = 10,
    kTenantIdFieldNumber = 13,
    kPrincipalIdFieldNumber = 14,
    kContextHintsFieldNumber = 11,
    kBudgetFieldNumber = 12,
    kPriorityFieldNumber = 3,
    kStepIndexFieldNumber = 9,
  };
  // map<string, string> env = 6;
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // map<string, string> labels = 15;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string topic = 2;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // string context_ptr = 4;
  void clear_context_ptr();
  const std::string& context_ptr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_context_ptr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_context_ptr();
  PROTOBUF_NODISCARD std::string* release_context_ptr();
  void set_allocated_context_ptr(std::string* context_ptr);
  private:
  const std::string& _internal_context_ptr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_context_ptr(const std::string& value);
  std::string* _internal_mutable_context_ptr();
  public:

  // string adapter_id = 5;
  void clear_adapter_id();
  const std::string& adapter_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_adapter_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_adapter_id();
  PROTOBUF_NODISCARD std::string* release_adapter_id();
  void set_allocated_adapter_id(std::string* adapter_id);
  private:
  const std::string& _internal_adapter_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adapter_id(const std::string& value);
  std::string* _internal_mutable_adapter_id();
  public:

  // string parent_job_id = 7;
  void clear_parent_job_id();
  const std::string& parent_job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_job_id();
  PROTOBUF_NODISCARD std::string* release_parent_job_id();
  void set_allocated_parent_job_id(std::string* parent_job_id);
  private:
  const std::string& _internal_parent_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_job_id(const std::string& value);
  std::string* _internal_mutable_parent_job_id();
  public:

  // string workflow_id = 8;
  void clear_workflow_id();
  const std::string& workflow_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workflow_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workflow_id();
  PROTOBUF_NODISCARD std::string* release_workflow_id();
  void set_allocated_workflow_id(std::string* workflow_id);
  private:
  const std::string& _internal_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow_id(const std::string& value);
  std::string* _internal_mutable_workflow_id();
  public:

  // string memory_id = 10;
  void clear_memory_id();
  const std::string& memory_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory_id();
  PROTOBUF_NODISCARD std::string* release_memory_id();
  void set_allocated_memory_id(std::string* memory_id);
  private:
  const std::string& _internal_memory_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory_id(const std::string& value);
  std::string* _internal_mutable_memory_id();
  public:

  // string tenant_id = 13;
  void clear_tenant_id();
  const std::string& tenant_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenant_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenant_id();
  PROTOBUF_NODISCARD std::string* release_tenant_id();
  void set_allocated_tenant_id(std::string* tenant_id);
  private:
  const std::string& _internal_tenant_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenant_id(const std::string& value);
  std::string* _internal_mutable_tenant_id();
  public:

  // string principal_id = 14;
  void clear_principal_id();
  const std::string& principal_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_principal_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_principal_id();
  PROTOBUF_NODISCARD std::string* release_principal_id();
  void set_allocated_principal_id(std::string* principal_id);
  private:
  const std::string& _internal_principal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_principal_id(const std::string& value);
  std::string* _internal_mutable_principal_id();
  public:

  // .coretex.agent.v1.ContextHints context_hints = 11;
  bool has_context_hints() const;
  private:
  bool _internal_has_context_hints() const;
  public:
  void clear_context_hints();
  const ::coretex::agent::v1::ContextHints& context_hints() const;
  PROTOBUF_NODISCARD ::coretex::agent::v1::ContextHints* release_context_hints();
  ::coretex::agent::v1::ContextHints* mutable_context_hints();
  void set_allocated_context_hints(::coretex::agent::v1::ContextHints* context_hints);
  private:
  const ::coretex::agent::v1::ContextHints& _internal_context_hints() const;
  ::coretex::agent::v1::ContextHints* _internal_mutable_context_hints();
  public:
  void unsafe_arena_set_allocated_context_hints(
      ::coretex::agent::v1::ContextHints* context_hints);
  ::coretex::agent::v1::ContextHints* unsafe_arena_release_context_hints();

  // .coretex.agent.v1.Budget budget = 12;
  bool has_budget() const;
  private:
  bool _internal_has_budget() const;
  public:
  void clear_budget();
  const ::coretex::agent::v1::Budget& budget() const;
  PROTOBUF_NODISCARD ::coretex::agent::v1::Budget* release_budget();
  ::coretex::agent::v1::Budget* mutable_budget();
  void set_allocated_budget(::coretex::agent::v1::Budget* budget);
  private:
  const ::coretex::agent::v1::Budget& _internal_budget() const;
  ::coretex::agent::v1::Budget* _internal_mutable_budget();
  public:
  void unsafe_arena_set_allocated_budget(
      ::coretex::agent::v1::Budget* budget);
  ::coretex::agent::v1::Budget* unsafe_arena_release_budget();

  // .coretex.agent.v1.JobPriority priority = 3;
  void clear_priority();
  ::coretex::agent::v1::JobPriority priority() const;
  void set_priority(::coretex::agent::v1::JobPriority value);
  private:
  ::coretex::agent::v1::JobPriority _internal_priority() const;
  void _internal_set_priority(::coretex::agent::v1::JobPriority value);
  public:

  // int32 step_index = 9;
  void clear_step_index();
  int32_t step_index() const;
  void set_step_index(int32_t value);
  private:
  int32_t _internal_step_index() const;
  void _internal_set_step_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:coretex.agent.v1.JobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        JobRequest_EnvEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> env_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        JobRequest_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr context_ptr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adapter_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workflow_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenant_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr principal_id_;
    ::coretex::agent::v1::ContextHints* context_hints_;
    ::coretex::agent::v1::Budget* budget_;
    int priority_;
    int32_t step_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coretex_2fagent_2fv1_2fjob_2eproto;
};
// -------------------------------------------------------------------

class JobResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:coretex.agent.v1.JobResult) */ {
 public:
  inline JobResult() : JobResult(nullptr) {}
  ~JobResult() override;
  explicit PROTOBUF_CONSTEXPR JobResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobResult(const JobResult& from);
  JobResult(JobResult&& from) noexcept
    : JobResult() {
    *this = ::std::move(from);
  }

  inline JobResult& operator=(const JobResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobResult& operator=(JobResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobResult* internal_default_instance() {
    return reinterpret_cast<const JobResult*>(
               &_JobResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(JobResult& a, JobResult& b) {
    a.Swap(&b);
  }
  inline void Swap(JobResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobResult& from) {
    JobResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "coretex.agent.v1.JobResult";
  }
  protected:
  explicit JobResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kResultPtrFieldNumber = 3,
    kWorkerIdFieldNumber = 4,
    kErrorCodeFieldNumber = 6,
    kErrorMessageFieldNumber = 7,
    kExecutionMsFieldNumber = 5,
    kStatusFieldNumber = 2,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string result_ptr = 3;
  void clear_result_ptr();
  const std::string& result_ptr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_ptr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_ptr();
  PROTOBUF_NODISCARD std::string* release_result_ptr();
  void set_allocated_result_ptr(std::string* result_ptr);
  private:
  const std::string& _internal_result_ptr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_ptr(const std::string& value);
  std::string* _internal_mutable_result_ptr();
  public:

  // string worker_id = 4;
  void clear_worker_id();
  const std::string& worker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_id();
  PROTOBUF_NODISCARD std::string* release_worker_id();
  void set_allocated_worker_id(std::string* worker_id);
  private:
  const std::string& _internal_worker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(const std::string& value);
  std::string* _internal_mutable_worker_id();
  public:

  // string error_code = 6;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // string error_message = 7;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int64 execution_ms = 5;
  void clear_execution_ms();
  int64_t execution_ms() const;
  void set_execution_ms(int64_t value);
  private:
  int64_t _internal_execution_ms() const;
  void _internal_set_execution_ms(int64_t value);
  public:

  // .coretex.agent.v1.JobStatus status = 2;
  void clear_status();
  ::coretex::agent::v1::JobStatus status() const;
  void set_status(::coretex::agent::v1::JobStatus value);
  private:
  ::coretex::agent::v1::JobStatus _internal_status() const;
  void _internal_set_status(::coretex::agent::v1::JobStatus value);
  public:

  // @@protoc_insertion_point(class_scope:coretex.agent.v1.JobResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_ptr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int64_t execution_ms_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coretex_2fagent_2fv1_2fjob_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ContextHints

// int32 max_input_tokens = 1;
inline void ContextHints::clear_max_input_tokens() {
  _impl_.max_input_tokens_ = 0;
}
inline int32_t ContextHints::_internal_max_input_tokens() const {
  return _impl_.max_input_tokens_;
}
inline int32_t ContextHints::max_input_tokens() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.ContextHints.max_input_tokens)
  return _internal_max_input_tokens();
}
inline void ContextHints::_internal_set_max_input_tokens(int32_t value) {
  
  _impl_.max_input_tokens_ = value;
}
inline void ContextHints::set_max_input_tokens(int32_t value) {
  _internal_set_max_input_tokens(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.ContextHints.max_input_tokens)
}

// bool allow_summarization = 2;
inline void ContextHints::clear_allow_summarization() {
  _impl_.allow_summarization_ = false;
}
inline bool ContextHints::_internal_allow_summarization() const {
  return _impl_.allow_summarization_;
}
inline bool ContextHints::allow_summarization() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.ContextHints.allow_summarization)
  return _internal_allow_summarization();
}
inline void ContextHints::_internal_set_allow_summarization(bool value) {
  
  _impl_.allow_summarization_ = value;
}
inline void ContextHints::set_allow_summarization(bool value) {
  _internal_set_allow_summarization(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.ContextHints.allow_summarization)
}

// bool allow_retrieval = 3;
inline void ContextHints::clear_allow_retrieval() {
  _impl_.allow_retrieval_ = false;
}
inline bool ContextHints::_internal_allow_retrieval() const {
  return _impl_.allow_retrieval_;
}
inline bool ContextHints::allow_retrieval() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.ContextHints.allow_retrieval)
  return _internal_allow_retrieval();
}
inline void ContextHints::_internal_set_allow_retrieval(bool value) {
  
  _impl_.allow_retrieval_ = value;
}
inline void ContextHints::set_allow_retrieval(bool value) {
  _internal_set_allow_retrieval(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.ContextHints.allow_retrieval)
}

// repeated string tags = 4;
inline int ContextHints::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int ContextHints::tags_size() const {
  return _internal_tags_size();
}
inline void ContextHints::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* ContextHints::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:coretex.agent.v1.ContextHints.tags)
  return _s;
}
inline const std::string& ContextHints::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& ContextHints::tags(int index) const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.ContextHints.tags)
  return _internal_tags(index);
}
inline std::string* ContextHints::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.ContextHints.tags)
  return _impl_.tags_.Mutable(index);
}
inline void ContextHints::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.ContextHints.tags)
}
inline void ContextHints::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:coretex.agent.v1.ContextHints.tags)
}
inline void ContextHints::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:coretex.agent.v1.ContextHints.tags)
}
inline void ContextHints::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:coretex.agent.v1.ContextHints.tags)
}
inline std::string* ContextHints::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void ContextHints::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:coretex.agent.v1.ContextHints.tags)
}
inline void ContextHints::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:coretex.agent.v1.ContextHints.tags)
}
inline void ContextHints::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:coretex.agent.v1.ContextHints.tags)
}
inline void ContextHints::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:coretex.agent.v1.ContextHints.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContextHints::tags() const {
  // @@protoc_insertion_point(field_list:coretex.agent.v1.ContextHints.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContextHints::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:coretex.agent.v1.ContextHints.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// Budget

// int64 max_input_tokens = 1;
inline void Budget::clear_max_input_tokens() {
  _impl_.max_input_tokens_ = int64_t{0};
}
inline int64_t Budget::_internal_max_input_tokens() const {
  return _impl_.max_input_tokens_;
}
inline int64_t Budget::max_input_tokens() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.Budget.max_input_tokens)
  return _internal_max_input_tokens();
}
inline void Budget::_internal_set_max_input_tokens(int64_t value) {
  
  _impl_.max_input_tokens_ = value;
}
inline void Budget::set_max_input_tokens(int64_t value) {
  _internal_set_max_input_tokens(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.Budget.max_input_tokens)
}

// int64 max_output_tokens = 2;
inline void Budget::clear_max_output_tokens() {
  _impl_.max_output_tokens_ = int64_t{0};
}
inline int64_t Budget::_internal_max_output_tokens() const {
  return _impl_.max_output_tokens_;
}
inline int64_t Budget::max_output_tokens() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.Budget.max_output_tokens)
  return _internal_max_output_tokens();
}
inline void Budget::_internal_set_max_output_tokens(int64_t value) {
  
  _impl_.max_output_tokens_ = value;
}
inline void Budget::set_max_output_tokens(int64_t value) {
  _internal_set_max_output_tokens(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.Budget.max_output_tokens)
}

// int64 max_total_tokens = 3;
inline void Budget::clear_max_total_tokens() {
  _impl_.max_total_tokens_ = int64_t{0};
}
inline int64_t Budget::_internal_max_total_tokens() const {
  return _impl_.max_total_tokens_;
}
inline int64_t Budget::max_total_tokens() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.Budget.max_total_tokens)
  return _internal_max_total_tokens();
}
inline void Budget::_internal_set_max_total_tokens(int64_t value) {
  
  _impl_.max_total_tokens_ = value;
}
inline void Budget::set_max_total_tokens(int64_t value) {
  _internal_set_max_total_tokens(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.Budget.max_total_tokens)
}

// int64 deadline_ms = 4;
inline void Budget::clear_deadline_ms() {
  _impl_.deadline_ms_ = int64_t{0};
}
inline int64_t Budget::_internal_deadline_ms() const {
  return _impl_.deadline_ms_;
}
inline int64_t Budget::deadline_ms() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.Budget.deadline_ms)
  return _internal_deadline_ms();
}
inline void Budget::_internal_set_deadline_ms(int64_t value) {
  
  _impl_.deadline_ms_ = value;
}
inline void Budget::set_deadline_ms(int64_t value) {
  _internal_set_deadline_ms(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.Budget.deadline_ms)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// JobRequest

// string job_id = 1;
inline void JobRequest::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& JobRequest::job_id() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.job_id)
}
inline std::string* JobRequest::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.job_id)
  return _s;
}
inline const std::string& JobRequest::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void JobRequest::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_job_id() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.job_id)
  return _impl_.job_id_.Release();
}
inline void JobRequest::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.job_id)
}

// string topic = 2;
inline void JobRequest::clear_topic() {
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& JobRequest::topic() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_topic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.topic)
}
inline std::string* JobRequest::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.topic)
  return _s;
}
inline const std::string& JobRequest::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void JobRequest::_internal_set_topic(const std::string& value) {
  
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_topic() {
  
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_topic() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.topic)
  return _impl_.topic_.Release();
}
inline void JobRequest::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.topic)
}

// .coretex.agent.v1.JobPriority priority = 3;
inline void JobRequest::clear_priority() {
  _impl_.priority_ = 0;
}
inline ::coretex::agent::v1::JobPriority JobRequest::_internal_priority() const {
  return static_cast< ::coretex::agent::v1::JobPriority >(_impl_.priority_);
}
inline ::coretex::agent::v1::JobPriority JobRequest::priority() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.priority)
  return _internal_priority();
}
inline void JobRequest::_internal_set_priority(::coretex::agent::v1::JobPriority value) {
  
  _impl_.priority_ = value;
}
inline void JobRequest::set_priority(::coretex::agent::v1::JobPriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.priority)
}

// string context_ptr = 4;
inline void JobRequest::clear_context_ptr() {
  _impl_.context_ptr_.ClearToEmpty();
}
inline const std::string& JobRequest::context_ptr() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.context_ptr)
  return _internal_context_ptr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_context_ptr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.context_ptr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.context_ptr)
}
inline std::string* JobRequest::mutable_context_ptr() {
  std::string* _s = _internal_mutable_context_ptr();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.context_ptr)
  return _s;
}
inline const std::string& JobRequest::_internal_context_ptr() const {
  return _impl_.context_ptr_.Get();
}
inline void JobRequest::_internal_set_context_ptr(const std::string& value) {
  
  _impl_.context_ptr_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_context_ptr() {
  
  return _impl_.context_ptr_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_context_ptr() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.context_ptr)
  return _impl_.context_ptr_.Release();
}
inline void JobRequest::set_allocated_context_ptr(std::string* context_ptr) {
  if (context_ptr != nullptr) {
    
  } else {
    
  }
  _impl_.context_ptr_.SetAllocated(context_ptr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.context_ptr_.IsDefault()) {
    _impl_.context_ptr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.context_ptr)
}

// string adapter_id = 5;
inline void JobRequest::clear_adapter_id() {
  _impl_.adapter_id_.ClearToEmpty();
}
inline const std::string& JobRequest::adapter_id() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.adapter_id)
  return _internal_adapter_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_adapter_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.adapter_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.adapter_id)
}
inline std::string* JobRequest::mutable_adapter_id() {
  std::string* _s = _internal_mutable_adapter_id();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.adapter_id)
  return _s;
}
inline const std::string& JobRequest::_internal_adapter_id() const {
  return _impl_.adapter_id_.Get();
}
inline void JobRequest::_internal_set_adapter_id(const std::string& value) {
  
  _impl_.adapter_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_adapter_id() {
  
  return _impl_.adapter_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_adapter_id() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.adapter_id)
  return _impl_.adapter_id_.Release();
}
inline void JobRequest::set_allocated_adapter_id(std::string* adapter_id) {
  if (adapter_id != nullptr) {
    
  } else {
    
  }
  _impl_.adapter_id_.SetAllocated(adapter_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.adapter_id_.IsDefault()) {
    _impl_.adapter_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.adapter_id)
}

// map<string, string> env = 6;
inline int JobRequest::_internal_env_size() const {
  return _impl_.env_.size();
}
inline int JobRequest::env_size() const {
  return _internal_env_size();
}
inline void JobRequest::clear_env() {
  _impl_.env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobRequest::_internal_env() const {
  return _impl_.env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobRequest::env() const {
  // @@protoc_insertion_point(field_map:coretex.agent.v1.JobRequest.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobRequest::_internal_mutable_env() {
  return _impl_.env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobRequest::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:coretex.agent.v1.JobRequest.env)
  return _internal_mutable_env();
}

// string parent_job_id = 7;
inline void JobRequest::clear_parent_job_id() {
  _impl_.parent_job_id_.ClearToEmpty();
}
inline const std::string& JobRequest::parent_job_id() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.parent_job_id)
  return _internal_parent_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_parent_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.parent_job_id)
}
inline std::string* JobRequest::mutable_parent_job_id() {
  std::string* _s = _internal_mutable_parent_job_id();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.parent_job_id)
  return _s;
}
inline const std::string& JobRequest::_internal_parent_job_id() const {
  return _impl_.parent_job_id_.Get();
}
inline void JobRequest::_internal_set_parent_job_id(const std::string& value) {
  
  _impl_.parent_job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_parent_job_id() {
  
  return _impl_.parent_job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_parent_job_id() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.parent_job_id)
  return _impl_.parent_job_id_.Release();
}
inline void JobRequest::set_allocated_parent_job_id(std::string* parent_job_id) {
  if (parent_job_id != nullptr) {
    
  } else {
    
  }
  _impl_.parent_job_id_.SetAllocated(parent_job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_job_id_.IsDefault()) {
    _impl_.parent_job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.parent_job_id)
}

// string workflow_id = 8;
inline void JobRequest::clear_workflow_id() {
  _impl_.workflow_id_.ClearToEmpty();
}
inline const std::string& JobRequest::workflow_id() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.workflow_id)
  return _internal_workflow_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_workflow_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.workflow_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.workflow_id)
}
inline std::string* JobRequest::mutable_workflow_id() {
  std::string* _s = _internal_mutable_workflow_id();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.workflow_id)
  return _s;
}
inline const std::string& JobRequest::_internal_workflow_id() const {
  return _impl_.workflow_id_.Get();
}
inline void JobRequest::_internal_set_workflow_id(const std::string& value) {
  
  _impl_.workflow_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_workflow_id() {
  
  return _impl_.workflow_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_workflow_id() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.workflow_id)
  return _impl_.workflow_id_.Release();
}
inline void JobRequest::set_allocated_workflow_id(std::string* workflow_id) {
  if (workflow_id != nullptr) {
    
  } else {
    
  }
  _impl_.workflow_id_.SetAllocated(workflow_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.workflow_id_.IsDefault()) {
    _impl_.workflow_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.workflow_id)
}

// int32 step_index = 9;
inline void JobRequest::clear_step_index() {
  _impl_.step_index_ = 0;
}
inline int32_t JobRequest::_internal_step_index() const {
  return _impl_.step_index_;
}
inline int32_t JobRequest::step_index() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.step_index)
  return _internal_step_index();
}
inline void JobRequest::_internal_set_step_index(int32_t value) {
  
  _impl_.step_index_ = value;
}
inline void JobRequest::set_step_index(int32_t value) {
  _internal_set_step_index(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.step_index)
}

// string memory_id = 10;
inline void JobRequest::clear_memory_id() {
  _impl_.memory_id_.ClearToEmpty();
}
inline const std::string& JobRequest::memory_id() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.memory_id)
  return _internal_memory_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_memory_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.memory_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.memory_id)
}
inline std::string* JobRequest::mutable_memory_id() {
  std::string* _s = _internal_mutable_memory_id();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.memory_id)
  return _s;
}
inline const std::string& JobRequest::_internal_memory_id() const {
  return _impl_.memory_id_.Get();
}
inline void JobRequest::_internal_set_memory_id(const std::string& value) {
  
  _impl_.memory_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_memory_id() {
  
  return _impl_.memory_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_memory_id() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.memory_id)
  return _impl_.memory_id_.Release();
}
inline void JobRequest::set_allocated_memory_id(std::string* memory_id) {
  if (memory_id != nullptr) {
    
  } else {
    
  }
  _impl_.memory_id_.SetAllocated(memory_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memory_id_.IsDefault()) {
    _impl_.memory_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.memory_id)
}

// .coretex.agent.v1.ContextHints context_hints = 11;
inline bool JobRequest::_internal_has_context_hints() const {
  return this != internal_default_instance() && _impl_.context_hints_ != nullptr;
}
inline bool JobRequest::has_context_hints() const {
  return _internal_has_context_hints();
}
inline void JobRequest::clear_context_hints() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_hints_ != nullptr) {
    delete _impl_.context_hints_;
  }
  _impl_.context_hints_ = nullptr;
}
inline const ::coretex::agent::v1::ContextHints& JobRequest::_internal_context_hints() const {
  const ::coretex::agent::v1::ContextHints* p = _impl_.context_hints_;
  return p != nullptr ? *p : reinterpret_cast<const ::coretex::agent::v1::ContextHints&>(
      ::coretex::agent::v1::_ContextHints_default_instance_);
}
inline const ::coretex::agent::v1::ContextHints& JobRequest::context_hints() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.context_hints)
  return _internal_context_hints();
}
inline void JobRequest::unsafe_arena_set_allocated_context_hints(
    ::coretex::agent::v1::ContextHints* context_hints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_hints_);
  }
  _impl_.context_hints_ = context_hints;
  if (context_hints) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:coretex.agent.v1.JobRequest.context_hints)
}
inline ::coretex::agent::v1::ContextHints* JobRequest::release_context_hints() {
  
  ::coretex::agent::v1::ContextHints* temp = _impl_.context_hints_;
  _impl_.context_hints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::coretex::agent::v1::ContextHints* JobRequest::unsafe_arena_release_context_hints() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.context_hints)
  
  ::coretex::agent::v1::ContextHints* temp = _impl_.context_hints_;
  _impl_.context_hints_ = nullptr;
  return temp;
}
inline ::coretex::agent::v1::ContextHints* JobRequest::_internal_mutable_context_hints() {
  
  if (_impl_.context_hints_ == nullptr) {
    auto* p = CreateMaybeMessage<::coretex::agent::v1::ContextHints>(GetArenaForAllocation());
    _impl_.context_hints_ = p;
  }
  return _impl_.context_hints_;
}
inline ::coretex::agent::v1::ContextHints* JobRequest::mutable_context_hints() {
  ::coretex::agent::v1::ContextHints* _msg = _internal_mutable_context_hints();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.context_hints)
  return _msg;
}
inline void JobRequest::set_allocated_context_hints(::coretex::agent::v1::ContextHints* context_hints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_hints_;
  }
  if (context_hints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context_hints);
    if (message_arena != submessage_arena) {
      context_hints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context_hints, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_hints_ = context_hints;
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.context_hints)
}

// .coretex.agent.v1.Budget budget = 12;
inline bool JobRequest::_internal_has_budget() const {
  return this != internal_default_instance() && _impl_.budget_ != nullptr;
}
inline bool JobRequest::has_budget() const {
  return _internal_has_budget();
}
inline void JobRequest::clear_budget() {
  if (GetArenaForAllocation() == nullptr && _impl_.budget_ != nullptr) {
    delete _impl_.budget_;
  }
  _impl_.budget_ = nullptr;
}
inline const ::coretex::agent::v1::Budget& JobRequest::_internal_budget() const {
  const ::coretex::agent::v1::Budget* p = _impl_.budget_;
  return p != nullptr ? *p : reinterpret_cast<const ::coretex::agent::v1::Budget&>(
      ::coretex::agent::v1::_Budget_default_instance_);
}
inline const ::coretex::agent::v1::Budget& JobRequest::budget() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.budget)
  return _internal_budget();
}
inline void JobRequest::unsafe_arena_set_allocated_budget(
    ::coretex::agent::v1::Budget* budget) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.budget_);
  }
  _impl_.budget_ = budget;
  if (budget) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:coretex.agent.v1.JobRequest.budget)
}
inline ::coretex::agent::v1::Budget* JobRequest::release_budget() {
  
  ::coretex::agent::v1::Budget* temp = _impl_.budget_;
  _impl_.budget_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::coretex::agent::v1::Budget* JobRequest::unsafe_arena_release_budget() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.budget)
  
  ::coretex::agent::v1::Budget* temp = _impl_.budget_;
  _impl_.budget_ = nullptr;
  return temp;
}
inline ::coretex::agent::v1::Budget* JobRequest::_internal_mutable_budget() {
  
  if (_impl_.budget_ == nullptr) {
    auto* p = CreateMaybeMessage<::coretex::agent::v1::Budget>(GetArenaForAllocation());
    _impl_.budget_ = p;
  }
  return _impl_.budget_;
}
inline ::coretex::agent::v1::Budget* JobRequest::mutable_budget() {
  ::coretex::agent::v1::Budget* _msg = _internal_mutable_budget();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.budget)
  return _msg;
}
inline void JobRequest::set_allocated_budget(::coretex::agent::v1::Budget* budget) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.budget_;
  }
  if (budget) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(budget);
    if (message_arena != submessage_arena) {
      budget = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, budget, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.budget_ = budget;
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.budget)
}

// string tenant_id = 13;
inline void JobRequest::clear_tenant_id() {
  _impl_.tenant_id_.ClearToEmpty();
}
inline const std::string& JobRequest::tenant_id() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.tenant_id)
  return _internal_tenant_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_tenant_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tenant_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.tenant_id)
}
inline std::string* JobRequest::mutable_tenant_id() {
  std::string* _s = _internal_mutable_tenant_id();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.tenant_id)
  return _s;
}
inline const std::string& JobRequest::_internal_tenant_id() const {
  return _impl_.tenant_id_.Get();
}
inline void JobRequest::_internal_set_tenant_id(const std::string& value) {
  
  _impl_.tenant_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_tenant_id() {
  
  return _impl_.tenant_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_tenant_id() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.tenant_id)
  return _impl_.tenant_id_.Release();
}
inline void JobRequest::set_allocated_tenant_id(std::string* tenant_id) {
  if (tenant_id != nullptr) {
    
  } else {
    
  }
  _impl_.tenant_id_.SetAllocated(tenant_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tenant_id_.IsDefault()) {
    _impl_.tenant_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.tenant_id)
}

// string principal_id = 14;
inline void JobRequest::clear_principal_id() {
  _impl_.principal_id_.ClearToEmpty();
}
inline const std::string& JobRequest::principal_id() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobRequest.principal_id)
  return _internal_principal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobRequest::set_principal_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.principal_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobRequest.principal_id)
}
inline std::string* JobRequest::mutable_principal_id() {
  std::string* _s = _internal_mutable_principal_id();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobRequest.principal_id)
  return _s;
}
inline const std::string& JobRequest::_internal_principal_id() const {
  return _impl_.principal_id_.Get();
}
inline void JobRequest::_internal_set_principal_id(const std::string& value) {
  
  _impl_.principal_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobRequest::_internal_mutable_principal_id() {
  
  return _impl_.principal_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobRequest::release_principal_id() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobRequest.principal_id)
  return _impl_.principal_id_.Release();
}
inline void JobRequest::set_allocated_principal_id(std::string* principal_id) {
  if (principal_id != nullptr) {
    
  } else {
    
  }
  _impl_.principal_id_.SetAllocated(principal_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.principal_id_.IsDefault()) {
    _impl_.principal_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobRequest.principal_id)
}

// map<string, string> labels = 15;
inline int JobRequest::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int JobRequest::labels_size() const {
  return _internal_labels_size();
}
inline void JobRequest::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobRequest::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobRequest::labels() const {
  // @@protoc_insertion_point(field_map:coretex.agent.v1.JobRequest.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobRequest::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobRequest::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:coretex.agent.v1.JobRequest.labels)
  return _internal_mutable_labels();
}

// -------------------------------------------------------------------

// JobResult

// string job_id = 1;
inline void JobResult::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& JobResult::job_id() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobResult.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobResult::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobResult.job_id)
}
inline std::string* JobResult::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobResult.job_id)
  return _s;
}
inline const std::string& JobResult::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void JobResult::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobResult::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobResult::release_job_id() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobResult.job_id)
  return _impl_.job_id_.Release();
}
inline void JobResult::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobResult.job_id)
}

// .coretex.agent.v1.JobStatus status = 2;
inline void JobResult::clear_status() {
  _impl_.status_ = 0;
}
inline ::coretex::agent::v1::JobStatus JobResult::_internal_status() const {
  return static_cast< ::coretex::agent::v1::JobStatus >(_impl_.status_);
}
inline ::coretex::agent::v1::JobStatus JobResult::status() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobResult.status)
  return _internal_status();
}
inline void JobResult::_internal_set_status(::coretex::agent::v1::JobStatus value) {
  
  _impl_.status_ = value;
}
inline void JobResult::set_status(::coretex::agent::v1::JobStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobResult.status)
}

// string result_ptr = 3;
inline void JobResult::clear_result_ptr() {
  _impl_.result_ptr_.ClearToEmpty();
}
inline const std::string& JobResult::result_ptr() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobResult.result_ptr)
  return _internal_result_ptr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobResult::set_result_ptr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_ptr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobResult.result_ptr)
}
inline std::string* JobResult::mutable_result_ptr() {
  std::string* _s = _internal_mutable_result_ptr();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobResult.result_ptr)
  return _s;
}
inline const std::string& JobResult::_internal_result_ptr() const {
  return _impl_.result_ptr_.Get();
}
inline void JobResult::_internal_set_result_ptr(const std::string& value) {
  
  _impl_.result_ptr_.Set(value, GetArenaForAllocation());
}
inline std::string* JobResult::_internal_mutable_result_ptr() {
  
  return _impl_.result_ptr_.Mutable(GetArenaForAllocation());
}
inline std::string* JobResult::release_result_ptr() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobResult.result_ptr)
  return _impl_.result_ptr_.Release();
}
inline void JobResult::set_allocated_result_ptr(std::string* result_ptr) {
  if (result_ptr != nullptr) {
    
  } else {
    
  }
  _impl_.result_ptr_.SetAllocated(result_ptr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_ptr_.IsDefault()) {
    _impl_.result_ptr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobResult.result_ptr)
}

// string worker_id = 4;
inline void JobResult::clear_worker_id() {
  _impl_.worker_id_.ClearToEmpty();
}
inline const std::string& JobResult::worker_id() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobResult.worker_id)
  return _internal_worker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobResult::set_worker_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.worker_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobResult.worker_id)
}
inline std::string* JobResult::mutable_worker_id() {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobResult.worker_id)
  return _s;
}
inline const std::string& JobResult::_internal_worker_id() const {
  return _impl_.worker_id_.Get();
}
inline void JobResult::_internal_set_worker_id(const std::string& value) {
  
  _impl_.worker_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobResult::_internal_mutable_worker_id() {
  
  return _impl_.worker_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobResult::release_worker_id() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobResult.worker_id)
  return _impl_.worker_id_.Release();
}
inline void JobResult::set_allocated_worker_id(std::string* worker_id) {
  if (worker_id != nullptr) {
    
  } else {
    
  }
  _impl_.worker_id_.SetAllocated(worker_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.worker_id_.IsDefault()) {
    _impl_.worker_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobResult.worker_id)
}

// int64 execution_ms = 5;
inline void JobResult::clear_execution_ms() {
  _impl_.execution_ms_ = int64_t{0};
}
inline int64_t JobResult::_internal_execution_ms() const {
  return _impl_.execution_ms_;
}
inline int64_t JobResult::execution_ms() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobResult.execution_ms)
  return _internal_execution_ms();
}
inline void JobResult::_internal_set_execution_ms(int64_t value) {
  
  _impl_.execution_ms_ = value;
}
inline void JobResult::set_execution_ms(int64_t value) {
  _internal_set_execution_ms(value);
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobResult.execution_ms)
}

// string error_code = 6;
inline void JobResult::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& JobResult::error_code() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobResult.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobResult::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobResult.error_code)
}
inline std::string* JobResult::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobResult.error_code)
  return _s;
}
inline const std::string& JobResult::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void JobResult::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* JobResult::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* JobResult::release_error_code() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobResult.error_code)
  return _impl_.error_code_.Release();
}
inline void JobResult::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobResult.error_code)
}

// string error_message = 7;
inline void JobResult::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& JobResult::error_message() const {
  // @@protoc_insertion_point(field_get:coretex.agent.v1.JobResult.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobResult::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:coretex.agent.v1.JobResult.error_message)
}
inline std::string* JobResult::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:coretex.agent.v1.JobResult.error_message)
  return _s;
}
inline const std::string& JobResult::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void JobResult::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* JobResult::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* JobResult::release_error_message() {
  // @@protoc_insertion_point(field_release:coretex.agent.v1.JobResult.error_message)
  return _impl_.error_message_.Release();
}
inline void JobResult::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:coretex.agent.v1.JobResult.error_message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace agent
}  // namespace coretex

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::coretex::agent::v1::JobPriority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::coretex::agent::v1::JobPriority>() {
  return ::coretex::agent::v1::JobPriority_descriptor();
}
template <> struct is_proto_enum< ::coretex::agent::v1::JobStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::coretex::agent::v1::JobStatus>() {
  return ::coretex::agent::v1::JobStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_coretex_2fagent_2fv1_2fjob_2eproto
